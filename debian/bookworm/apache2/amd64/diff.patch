From 88304321841a2fe8bd5eacc70e69418b0b545ca5 Mon Sep 17 00:00:00 2001
From: Eric Covener <covener@apache.org>
Date: Mon, 7 Jul 2025 12:05:49 +0000
Subject: [PATCH] backport 1927036 from trunk

  tolerate missing host header in h2 proxy

Reviewed By: jorton, icing, rpluem



git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/branches/2.4.x@1927044 13f79535-47bb-0310-9956-ffa450edef68
---
 modules/http2/h2_proxy_session.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/modules/http2/h2_proxy_session.c b/modules/http2/h2_proxy_session.c
index d5d0f9bc6bc..2cfbb5f5d4b 100644
--- a/modules/http2/h2_proxy_session.c
+++ b/modules/http2/h2_proxy_session.c
@@ -850,6 +850,18 @@ static apr_status_t open_stream(h2_proxy_session *session, const char *url,
     dconf = ap_get_module_config(r->per_dir_config, &proxy_module);
     if (dconf->preserve_host) {
         authority = orig_host;
+        if (!authority) {
+            /* Duplicate mod_proxy behaviour if ProxyPreserveHost is
+             * used but an "HTTP/0.9" request is received without a
+             * Host: header */
+            authority = r->server->server_hostname;
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10511)
+                          "HTTP/0.9 request (with no host line) "
+                          "on incoming request and preserve host set "
+                          "forcing hostname to be %s for uri %s",
+                          authority, r->uri);
+            apr_table_setn(r->headers_in, "Host", authority);
+        }
     }
     else {
         authority = puri.hostname;From 6ec7d1368d0e100a0ece7a31510582b1e7873b4a Mon Sep 17 00:00:00 2001
From: Security Analysis Team
Date: Thu, 31 Jul 2025 19:27:38 +0530
Subject: [PATCH] Add CVE-2007-0086 security analysis documentation

This document provides technical analysis confirming CVE-2007-0086
should be classified as a false positive in Debian Bookworm container
environments due to TCP buffer limitations that prevent the vulnerability
from being exploitable.

- Includes TCP buffer analysis comparing container vs host settings
- Documents Red Hat position validation for consistency
- Provides risk assessment and test environment details
- Recommends marking as FALSE POSITIVE with supporting evidence
- References Red Hat CVE advisory for additional context
---
 ROOT-SECURITY-RELEASE.md | 63 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 63 insertions(+)
 create mode 100644 ROOT-SECURITY-RELEASE.md

diff --git a/ROOT-SECURITY-RELEASE.md b/ROOT-SECURITY-RELEASE.md
new file mode 100644
index 0000000..b7ef2a4
--- /dev/null
+++ b/ROOT-SECURITY-RELEASE.md
@@ -0,0 +1,63 @@
+
+# CVE-2007-0086
+
+**RECOMMENDATION: Mark as FALSE POSITIVE**
+
+## Summary
+
+Technical analysis confirms CVE-2007-0086 should be classified as a false positive in Debian Bookworm container environments. The same TCP buffer limitations that Red Hat uses to dismiss this vulnerability apply equally to Debian containers.
+
+## Key Technical Findings
+
+### TCP Buffer Analysis:
+- **Container TCP Settings:** 4096    16384   4194304 (4.00 MB max)
+- **Host TCP Settings:**      4096    16384   4194304 (4.00 MB max)
+
+### Container Inheritance Behavior:
+
+✅ Container TCP settings inherited directly from host system
+
+✅ Normal containers cannot modify TCP buffer settings (read-only)
+
+✅ Same 4 MB buffer limit that constrains CVE impact
+
+## Red Hat Position Validation
+
+**Red Hat's stance:** RHEL's 4 MB TCP send buffer limit prevents the "infinite data flow" scenario described in CVE-2007-0086
+
+**Our validation:** Debian Bookworm containers have identical 4 MB TCP buffer constraints, providing equivalent protection
+
+## Risk Assessment
+
+- **Maximum impact:** 4 MB per connection (not infinite as CVE suggests)
+- **Attack complexity:** Equivalent to legitimate large file downloads
+- **Privilege escalation:** None
+- **Data exposure:** None
+
+## Test Environment
+
+- **Container:** debian:bookworm with Apache 2.4.62-1~deb12u2
+- **Verification:** Direct TCP buffer measurement and inheritance testing
+- **Host System:** Linux 6.8.0-64-generic
+
+## Recommendation Actions
+
+- Update vulnerability status to FALSE POSITIVE
+- Document justification in security tracking system
+- Apply consistent standards across container distributions with same TCP constraints
+
+## Supporting Evidence
+
+| Metric                 | Host       | Debian Container | Red Hat |
+|------------------------|------------|------------------|---------|
+| TCP Buffer Max         | 4 MB       | 4 MB             | 4 MB    |
+| CVE Mitigation         | Present    | Present          | Present |
+| Security Impact        | Low        | Low              | Low     |
+
+## Conclusion
+
+Inconsistent vulnerability classification despite identical technical limitations. Container inherits host-level mitigations that effectively prevent the CVE attack scenario.
+
+## References
+
+- [Red Hat CVE-2007-0086 Security Advisory](https://access.redhat.com/security/cve/cve-2007-0086) 
\ No newline at end of file
-- 
2.43.0

From 350bdead419aa073badbd158dff3dd8f569c838a Mon Sep 17 00:00:00 2001
From: musthak2 <musthak@focaloid.com>
Date: Wed, 30 Jul 2025 11:54:59 +0530
Subject: [PATCH] Complete CVE-2024-43204 fix: prevent SSRF in mod_headers

- Add header direction check (r->headers_in != headers) for all Content-Type operations
- Fix hdr_unset case to properly handle Content-Type response headers
- Fix hdr_edit/hdr_edit_r cases to prevent response header modification
- Use ap_set_content_type_ex with proper flags for consistency

This prevents RequestHeader operations on Content-Type from inadvertently
modifying response headers, addressing the SSRF vulnerability.
---
 modules/metadata/mod_headers.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/modules/metadata/mod_headers.c b/modules/metadata/mod_headers.c
index 9a2a196474..57da3fc538 100644
--- a/modules/metadata/mod_headers.c
+++ b/modules/metadata/mod_headers.c
@@ -784,7 +784,7 @@ static int do_headers_fixup(request_rec *r, apr_table_t *headers,
         case hdr_set:
             if (r->headers_in != headers &&
                 !ap_cstr_casecmp(hdr->header, "Content-Type")) {
-                 ap_set_content_type(r, process_tags(hdr, r));
+                 ap_set_content_type_ex(r, process_tags(hdr, r), 1);
             }
             apr_table_setn(headers, hdr->header, process_tags(hdr, r));
             break;
@@ -792,13 +792,17 @@ static int do_headers_fixup(request_rec *r, apr_table_t *headers,
             if (NULL == apr_table_get(headers, hdr->header)) {
                 if (r->headers_in != headers &&
                     !ap_cstr_casecmp(hdr->header, "Content-Type")) {
-                    ap_set_content_type(r, process_tags(hdr, r));
+                    ap_set_content_type_ex(r, process_tags(hdr, r), 1);
                 }
                 apr_table_setn(headers, hdr->header, process_tags(hdr, r));
             }
             break;
         case hdr_unset:
             apr_table_unset(headers, hdr->header);
+            if (r->headers_in != headers &&
+                !ap_cstr_casecmp(hdr->header, "Content-Type")) {
+                ap_set_content_type(r, NULL);
+            }
             break;
         case hdr_echo:
             v.r = r;
@@ -811,7 +815,7 @@ static int do_headers_fixup(request_rec *r, apr_table_t *headers,
                 const char *repl = process_regexp(hdr, r->content_type, r);
                 if (repl == NULL)
                     return 0;
-                ap_set_content_type_ex(r, repl, 1);
+                if (r->headers_in != headers) ap_set_content_type_ex(r, repl, 1);
             }
             if (apr_table_get(headers, hdr->header)) {
                 edit_do ed;
-- 
2.34.1From 23f296b64f29d03c4b25224be98553c4f5d7d78d Mon Sep 17 00:00:00 2001
From: Eric Covener <covener@apache.org>
Date: Mon, 7 Jul 2025 12:01:02 +0000
Subject: [PATCH] backport 1927032 from trunk

  header only

Reviewed By: rpluem, jorton, ylavic

git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/branches/2.4.x@1927040 13f79535-47bb-0310-9956-ffa450edef68
---
 modules/metadata/mod_headers.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/modules/metadata/mod_headers.c b/modules/metadata/mod_headers.c
index 4838bd6cd0..9a2a196474 100644
--- a/modules/metadata/mod_headers.c
+++ b/modules/metadata/mod_headers.c
@@ -782,15 +782,17 @@ static int do_headers_fixup(request_rec *r, apr_table_t *headers,
             }
             break;
         case hdr_set:
-            if (!ap_cstr_casecmp(hdr->header, "Content-Type")) {
-                 ap_set_content_type_ex(r, process_tags(hdr, r), 1);
+            if (r->headers_in != headers &&
+                !ap_cstr_casecmp(hdr->header, "Content-Type")) {
+                 ap_set_content_type(r, process_tags(hdr, r));
             }
             apr_table_setn(headers, hdr->header, process_tags(hdr, r));
             break;
         case hdr_setifempty:
             if (NULL == apr_table_get(headers, hdr->header)) {
-                if (!ap_cstr_casecmp(hdr->header, "Content-Type")) {
-                    ap_set_content_type_ex(r, process_tags(hdr, r), 1);
+                if (r->headers_in != headers &&
+                    !ap_cstr_casecmp(hdr->header, "Content-Type")) {
+                    ap_set_content_type(r, process_tags(hdr, r));
                 }
                 apr_table_setn(headers, hdr->header, process_tags(hdr, r));
             }
-- 
2.34.1

From c4cfa50c9068e8b8134c530ab21674e77d1278a2 Mon Sep 17 00:00:00 2001
From: Eric Covener <covener@apache.org>
Date: Mon, 7 Jul 2025 12:04:49 +0000
Subject: [PATCH] backport 1927035 from trunk

  update SNI validation

Reviewed By: rpluem, jorton, covener, ylavic



git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/branches/2.4.x@1927043 13f79535-47bb-0310-9956-ffa450edef68
---
 modules/ssl/ssl_engine_kernel.c | 28 +++++++++++++++-------------
 1 file changed, 15 insertions(+), 13 deletions(-)

Index: apache2-2.4.62/modules/ssl/ssl_engine_kernel.c
===================================================================
--- apache2-2.4.62.orig/modules/ssl/ssl_engine_kernel.c
+++ apache2-2.4.62/modules/ssl/ssl_engine_kernel.c
@@ -371,19 +371,6 @@ int ssl_hook_ReadReq(request_rec *r)
                             " provided in HTTP request", servername);
                 return HTTP_BAD_REQUEST;
             }
-            if (r->server != handshakeserver 
-                && !ssl_server_compatible(sslconn->server, r->server)) {
-                /* 
-                 * The request does not select the virtual host that was
-                 * selected by the SNI and its SSL parameters are different
-                 */
-                
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02032)
-                             "Hostname %s provided via SNI and hostname %s provided"
-                             " via HTTP have no compatible SSL setup",
-                             servername, r->hostname);
-                return HTTP_MISDIRECTED_REQUEST;
-            }
         }
         else if (((sc->strict_sni_vhost_check == SSL_ENABLED_TRUE)
                   || hssc->strict_sni_vhost_check == SSL_ENABLED_TRUE)
@@ -404,6 +391,21 @@ int ssl_hook_ReadReq(request_rec *r)
                            "which is required to access this server.<br />\n");
             return HTTP_FORBIDDEN;
         }
+        if (r->server != handshakeserver
+            && !ssl_server_compatible(sslconn->server, r->server)) {
+            /*
+             * The request does not select the virtual host that was
+             * selected for handshaking and its SSL parameters are different
+             */
+
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02032)
+                         "Hostname %s %s and hostname %s provided"
+                         " via HTTP have no compatible SSL setup",
+                         servername ? servername : handshakeserver->server_hostname,
+                         servername ? "provided via SNI" : "(default host as no SNI was provided)",
+                         r->hostname);
+            return HTTP_MISDIRECTED_REQUEST;
+        }
     }
 #endif
     modssl_set_app_data2(ssl, r);
From c01e60707048be14a510f0a92128a5227923215c Mon Sep 17 00:00:00 2001
From: Eric Covener <covener@apache.org>
Date: Mon, 7 Jul 2025 12:03:42 +0000
Subject: [PATCH] backport 1927034 from trunk

  escape ssl vars

Reviewed By: rpluem, jorton, covener, ylavic



git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/branches/2.4.x@1927042 13f79535-47bb-0310-9956-ffa450edef68
---
 modules/ssl/ssl_engine_vars.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/modules/ssl/ssl_engine_vars.c b/modules/ssl/ssl_engine_vars.c
index 418d849e00e..4060c0f6a63 100644
--- a/modules/ssl/ssl_engine_vars.c
+++ b/modules/ssl/ssl_engine_vars.c
@@ -1208,8 +1208,9 @@ static const char *ssl_var_log_handler_c(request_rec *r, char *a)
         result = "-";
     else if (strEQ(a, "errstr"))
         result = (char *)sslconn->verify_error;
-    if (result != NULL && result[0] == NUL)
-        result = NULL;
+    if (result) {
+        result = *result ? ap_escape_logitem(r->pool, result) : NULL;
+    }
     return result;
 }
 
@@ -1222,8 +1223,9 @@ static const char *ssl_var_log_handler_x(request_rec *r, char *a)
     char *result;
 
     result = ssl_var_lookup(r->pool, r->server, r->connection, r, a);
-    if (result != NULL && result[0] == NUL)
-        result = NULL;
+    if (result) {
+        result = *result ? ap_escape_logitem(r->pool, result) : NULL;
+    }
     return result;
 }
 
From a7a9d814c7c23e990283277230ddd5a9efec27c7 Mon Sep 17 00:00:00 2001
From: Eric Covener <covener@apache.org>
Date: Mon, 7 Jul 2025 11:59:38 +0000
Subject: [PATCH] fix header merging

Reviewed By: rpluem, jorton, ylavic



git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/branches/2.4.x@1927039 13f79535-47bb-0310-9956-ffa450edef68
---
 modules/http/http_filters.c | 248 +++++++++++++++++++-----------------
 1 file changed, 128 insertions(+), 120 deletions(-)

diff --git a/modules/http/http_filters.c b/modules/http/http_filters.c
index 60b44d78580..732fb8eb6a7 100644
--- a/modules/http/http_filters.c
+++ b/modules/http/http_filters.c
@@ -1300,107 +1300,10 @@ typedef struct header_filter_ctx {
     int headers_sent;
 } header_filter_ctx;
 
-AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f,
-                                                           apr_bucket_brigade *b)
+static void merge_response_headers(request_rec *r, const char **protocol)
 {
-    request_rec *r = f->r;
-    conn_rec *c = r->connection;
-    const char *clheader;
-    int header_only = (r->header_only || AP_STATUS_IS_HEADER_ONLY(r->status));
-    const char *protocol = NULL;
-    apr_bucket *e;
-    apr_bucket_brigade *b2;
-    header_struct h;
-    header_filter_ctx *ctx = f->ctx;
-    const char *ctype;
-    ap_bucket_error *eb = NULL;
-    apr_status_t rv = APR_SUCCESS;
-    int recursive_error = 0;
-
-    AP_DEBUG_ASSERT(!r->main);
-
-    if (!ctx) {
-        ctx = f->ctx = apr_pcalloc(r->pool, sizeof(header_filter_ctx));
-    }
-    else if (ctx->headers_sent) {
-        /* Eat body if response must not have one. */
-        if (header_only) {
-            /* Still next filters may be waiting for EOS, so pass it (alone)
-             * when encountered and be done with this filter.
-             */
-            e = APR_BRIGADE_LAST(b);
-            if (e != APR_BRIGADE_SENTINEL(b) && APR_BUCKET_IS_EOS(e)) {
-                APR_BUCKET_REMOVE(e);
-                apr_brigade_cleanup(b);
-                APR_BRIGADE_INSERT_HEAD(b, e);
-                ap_remove_output_filter(f);
-                rv = ap_pass_brigade(f->next, b);
-            }
-            apr_brigade_cleanup(b);
-            return rv;
-        }
-    }
-
-    for (e = APR_BRIGADE_FIRST(b);
-         e != APR_BRIGADE_SENTINEL(b);
-         e = APR_BUCKET_NEXT(e))
-    {
-        if (AP_BUCKET_IS_ERROR(e) && !eb) {
-            eb = e->data;
-            continue;
-        }
-        /*
-         * If we see an EOC bucket it is a signal that we should get out
-         * of the way doing nothing.
-         */
-        if (AP_BUCKET_IS_EOC(e)) {
-            ap_remove_output_filter(f);
-            return ap_pass_brigade(f->next, b);
-        }
-    }
-
-    if (!ctx->headers_sent && !check_headers(r)) {
-        /* We may come back here from ap_die() below,
-         * so clear anything from this response.
-         */
-        apr_table_clear(r->headers_out);
-        apr_table_clear(r->err_headers_out);
-        r->content_type = r->content_encoding = NULL;
-        r->content_languages = NULL;
-        r->clength = r->chunked = 0;
-        apr_brigade_cleanup(b);
-
-        /* Don't recall ap_die() if we come back here (from its own internal
-         * redirect or error response), otherwise we can end up in infinite
-         * recursion; better fall through with 500, minimal headers and an
-         * empty body (EOS only).
-         */
-        if (!check_headers_recursion(r)) {
-            ap_die(HTTP_INTERNAL_SERVER_ERROR, r);
-            return AP_FILTER_ERROR;
-        }
-        r->status = HTTP_INTERNAL_SERVER_ERROR;
-        e = ap_bucket_eoc_create(c->bucket_alloc);
-        APR_BRIGADE_INSERT_TAIL(b, e);
-        e = apr_bucket_eos_create(c->bucket_alloc);
-        APR_BRIGADE_INSERT_TAIL(b, e);
-        ap_set_content_length(r, 0);
-        recursive_error = 1;
-    }
-    else if (eb) {
-        int status;
-        status = eb->status;
-        apr_brigade_cleanup(b);
-        ap_die(status, r);
-        return AP_FILTER_ERROR;
-    }
-
-    if (r->assbackwards) {
-        r->sent_bodyct = 1;
-        ap_remove_output_filter(f);
-        rv = ap_pass_brigade(f->next, b);
-        goto out;
-    }
+    const char *ctype = NULL;
+    const char *clheader = NULL;
 
     /*
      * Now that we are ready to send a response, we need to combine the two
@@ -1430,6 +1333,9 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f,
         fixup_vary(r);
     }
 
+    /* determine the protocol and whether we should use keepalives. */
+    basic_http_header_check(r, protocol);
+    ap_set_keepalive(r);
 
     /*
      * Control cachability for non-cacheable responses if not already set by
@@ -1449,10 +1355,6 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f,
         apr_table_unset(r->headers_out, "ETag");
     }
 
-    /* determine the protocol and whether we should use keepalives. */
-    basic_http_header_check(r, &protocol);
-    ap_set_keepalive(r);
-
     /* 204/304 responses don't have content related headers */
     if (AP_STATUS_IS_HEADER_ONLY(r->status)) {
         apr_table_unset(r->headers_out, "Transfer-Encoding");
@@ -1513,30 +1415,136 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f,
         && !strcmp(clheader, "0")) {
         apr_table_unset(r->headers_out, "Content-Length");
     }
+}
 
-    b2 = apr_brigade_create(r->pool, c->bucket_alloc);
-    basic_http_header(r, b2, protocol);
-
-    h.pool = r->pool;
-    h.bb = b2;
+AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f,
+                                                           apr_bucket_brigade *b)
+{
+    request_rec *r = f->r;
+    conn_rec *c = r->connection;
+    int header_only = (r->header_only || AP_STATUS_IS_HEADER_ONLY(r->status));
+    apr_bucket *e;
+    apr_bucket_brigade *b2;
+    header_struct h;
+    header_filter_ctx *ctx = f->ctx;
+    ap_bucket_error *eb = NULL;
+    apr_status_t rv = APR_SUCCESS;
+    int recursive_error = 0;
+    const char *protocol;
 
-    send_all_header_fields(&h, r);
+    AP_DEBUG_ASSERT(!r->main);
 
-    terminate_header(b2);
+    if (!ctx) {
+        ctx = f->ctx = apr_pcalloc(r->pool, sizeof(header_filter_ctx));
+    }
+    else if (ctx->headers_sent) {
+        /* Eat body if response must not have one. */
+        if (header_only) {
+            /* Still next filters may be waiting for EOS, so pass it (alone)
+             * when encountered and be done with this filter.
+             */
+            e = APR_BRIGADE_LAST(b);
+            if (e != APR_BRIGADE_SENTINEL(b) && APR_BUCKET_IS_EOS(e)) {
+                APR_BUCKET_REMOVE(e);
+                apr_brigade_cleanup(b);
+                APR_BRIGADE_INSERT_HEAD(b, e);
+                ap_remove_output_filter(f);
+                rv = ap_pass_brigade(f->next, b);
+            }
+            apr_brigade_cleanup(b);
+            return rv;
+        }
+    }
 
-    if (header_only) {
-        e = APR_BRIGADE_LAST(b);
-        if (e != APR_BRIGADE_SENTINEL(b) && APR_BUCKET_IS_EOS(e)) {
-            APR_BUCKET_REMOVE(e);
-            APR_BRIGADE_INSERT_TAIL(b2, e);
+    for (e = APR_BRIGADE_FIRST(b);
+         e != APR_BRIGADE_SENTINEL(b);
+         e = APR_BUCKET_NEXT(e))
+    {
+        if (AP_BUCKET_IS_ERROR(e) && !eb) {
+            eb = e->data;
+            continue;
+        }
+        /*
+         * If we see an EOC bucket it is a signal that we should get out
+         * of the way doing nothing.
+         */
+        if (AP_BUCKET_IS_EOC(e)) {
             ap_remove_output_filter(f);
+            return ap_pass_brigade(f->next, b);
+        }
+    }
+
+    if (!ctx->headers_sent) {
+        merge_response_headers(r, &protocol);
+        if (!check_headers(r)) {
+            /* We may come back here from ap_die() below,
+             * so clear anything from this response.
+             */
+            apr_table_clear(r->headers_out);
+            apr_table_clear(r->err_headers_out);
+            r->content_type = r->content_encoding = NULL;
+            r->content_languages = NULL;
+            r->clength = r->chunked = 0;
+            apr_brigade_cleanup(b);
+
+            /* Don't recall ap_die() if we come back here (from its own internal
+             * redirect or error response), otherwise we can end up in infinite
+             * recursion; better fall through with 500, minimal headers and an
+             * empty body (EOS only).
+             */
+            if (!check_headers_recursion(r)) {
+                ap_die(HTTP_INTERNAL_SERVER_ERROR, r);
+                return AP_FILTER_ERROR;
+            }
+            r->status = HTTP_INTERNAL_SERVER_ERROR;
+            e = ap_bucket_eoc_create(c->bucket_alloc);
+            APR_BRIGADE_INSERT_TAIL(b, e);
+            e = apr_bucket_eos_create(c->bucket_alloc);
+            APR_BRIGADE_INSERT_TAIL(b, e);
+            ap_set_content_length(r, 0);
+            recursive_error = 1;
+        }
+        else if (eb) {
+            int status;
+            status = eb->status;
+            apr_brigade_cleanup(b);
+            ap_die(status, r);
+            return AP_FILTER_ERROR;
         }
-        apr_brigade_cleanup(b);
     }
 
-    rv = ap_pass_brigade(f->next, b2);
-    apr_brigade_cleanup(b2);
-    ctx->headers_sent = 1;
+    if (r->assbackwards) {
+        r->sent_bodyct = 1;
+        ap_remove_output_filter(f);
+        rv = ap_pass_brigade(f->next, b);
+        goto out;
+    }
+
+    if (!ctx->headers_sent) {
+        b2 = apr_brigade_create(r->pool, c->bucket_alloc);
+        basic_http_header(r, b2, protocol);
+
+        h.pool = r->pool;
+        h.bb = b2;
+
+        send_all_header_fields(&h, r);
+
+        terminate_header(b2);
+
+        if (header_only) {
+            e = APR_BRIGADE_LAST(b);
+            if (e != APR_BRIGADE_SENTINEL(b) && APR_BUCKET_IS_EOS(e)) {
+                APR_BUCKET_REMOVE(e);
+                APR_BRIGADE_INSERT_TAIL(b2, e);
+                ap_remove_output_filter(f);
+            }
+            apr_brigade_cleanup(b);
+        }
+
+        rv = ap_pass_brigade(f->next, b2);
+        apr_brigade_cleanup(b2);
+        ctx->headers_sent = 1;
+    }
 
     if (rv != APR_SUCCESS || header_only) {
         goto out;
From 636c48c4118d4b3370d9ed16497b3e55a214a963 Mon Sep 17 00:00:00 2001
From: Eric Covener <covener@apache.org>
Date: Mon, 7 Jul 2025 12:12:49 +0000
Subject: [PATCH] backport 1927038 from trunk

  improve h2 header error handling

Rewviewed By: icing, covener, rpluem


git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/branches/2.4.x@1927046 13f79535-47bb-0310-9956-ffa450edef68
---
 modules/http2/h2_request.c                    | 12 ++--
 modules/http2/h2_request.h                    |  8 ++-
 modules/http2/h2_session.c                    | 31 ++++++++-
 modules/http2/h2_session.h                    |  3 +
 modules/http2/h2_stream.c                     | 69 ++++++++++++-------
 modules/http2/h2_util.c                       | 51 ++++++++------
 modules/http2/h2_util.h                       | 11 ++-
 test/modules/http2/test_200_header_invalid.py |  4 +-
 8 files changed, 130 insertions(+), 59 deletions(-)

diff --git a/modules/http2/h2_request.c b/modules/http2/h2_request.c
index 2713947c37..6373e0a244 100644
--- a/modules/http2/h2_request.c
+++ b/modules/http2/h2_request.c
@@ -64,18 +64,20 @@ typedef struct {
     apr_table_t *headers;
     apr_pool_t *pool;
     apr_status_t status;
+    h2_hd_scratch *scratch;
 } h1_ctx;
 
 static int set_h1_header(void *ctx, const char *key, const char *value)
 {
     h1_ctx *x = ctx;
     int was_added;
-    h2_req_add_header(x->headers, x->pool, key, strlen(key), value, strlen(value), 0, &was_added);
+    h2_req_add_header(x->headers, x->pool, key, strlen(key),
+                      value, strlen(value), x->scratch, &was_added);
     return 1;
 }
 
 apr_status_t h2_request_rcreate(h2_request **preq, apr_pool_t *pool, 
-                                request_rec *r)
+                                request_rec *r, h2_hd_scratch *scratch)
 {
     h2_request *req;
     const char *scheme, *authority, *path;
@@ -125,6 +127,7 @@ apr_status_t h2_request_rcreate(h2_request **preq, apr_pool_t *pool,
     x.pool = pool;
     x.headers = req->headers;
     x.status = APR_SUCCESS;
+    x.scratch = scratch;
     apr_table_do(set_h1_header, &x, r->headers_in, NULL);
 
     *preq = req;
@@ -134,7 +137,8 @@ apr_status_t h2_request_rcreate(h2_request **preq, apr_pool_t *pool,
 apr_status_t h2_request_add_header(h2_request *req, apr_pool_t *pool,
                                    const char *name, size_t nlen,
                                    const char *value, size_t vlen,
-                                   size_t max_field_len, int *pwas_added)
+                                   struct h2_hd_scratch *scratch,
+                                   int *pwas_added)
 {
     apr_status_t status = APR_SUCCESS;
 
@@ -185,7 +189,7 @@ apr_status_t h2_request_add_header(h2_request *req, apr_pool_t *pool,
     else {
         /* non-pseudo header, add to table */
         status = h2_req_add_header(req->headers, pool, name, nlen, value, vlen,
-                                   max_field_len, pwas_added);
+                                   scratch, pwas_added);
     }
 
     return status;
diff --git a/modules/http2/h2_request.h b/modules/http2/h2_request.h
index 7e20b69724..ae6b6a2510 100644
--- a/modules/http2/h2_request.h
+++ b/modules/http2/h2_request.h
@@ -19,17 +19,21 @@
 
 #include "h2.h"
 
+struct h2_hd_scratch;
+
 h2_request *h2_request_create(int id, apr_pool_t *pool, const char *method,
                               const char *scheme, const char *authority,
                               const char *path, apr_table_t *header);
 
 apr_status_t h2_request_rcreate(h2_request **preq, apr_pool_t *pool,
-                                request_rec *r);
+                                request_rec *r,
+                                struct h2_hd_scratch *scratch);
 
 apr_status_t h2_request_add_header(h2_request *req, apr_pool_t *pool,
                                    const char *name, size_t nlen,
                                    const char *value, size_t vlen,
-                                   size_t max_field_len, int *pwas_added);
+                                   struct h2_hd_scratch *scratch,
+                                   int *pwas_added);
 
 apr_status_t h2_request_add_trailer(h2_request *req, apr_pool_t *pool,
                                     const char *name, size_t nlen,
diff --git a/modules/http2/h2_session.c b/modules/http2/h2_session.c
index 5724fdadb0..fad945effd 100644
--- a/modules/http2/h2_session.c
+++ b/modules/http2/h2_session.c
@@ -109,13 +109,29 @@ static void cleanup_unprocessed_streams(h2_session *session)
     h2_mplx_c1_streams_do(session->mplx, rst_unprocessed_stream, session);
 }
 
+/* APR callback invoked if allocation fails. */
+static int abort_on_oom(int retcode)
+{
+    ap_abort_on_oom();
+    return retcode; /* unreachable, hopefully. */
+}
+
 static h2_stream *h2_session_open_stream(h2_session *session, int stream_id,
                                          int initiated_on)
 {
     h2_stream * stream;
+    apr_allocator_t *allocator;
     apr_pool_t *stream_pool;
+    apr_status_t rv;
     
-    apr_pool_create(&stream_pool, session->pool);
+    rv = apr_allocator_create(&allocator);
+    if (rv != APR_SUCCESS)
+      return NULL;
+
+    apr_allocator_max_free_set(allocator, ap_max_mem_free);
+    apr_pool_create_ex(&stream_pool, session->pool, NULL, allocator);
+    apr_allocator_owner_set(allocator, stream_pool);
+    apr_pool_abort_set(abort_on_oom, stream_pool);
     apr_pool_tag(stream_pool, "h2_stream");
     
     stream = h2_stream_create(stream_id, stream_pool, session, 
@@ -942,6 +958,14 @@ apr_status_t h2_session_create(h2_session **psession, conn_rec *c, request_rec *
     }
 
     h2_c1_io_init(&session->io, session);
+    /* setup request header scratch buffers */
+    session->hd_scratch.max_len = session->s->limit_req_fieldsize?
+        session->s->limit_req_fieldsize : 8190;
+    session->hd_scratch.name =
+        apr_pcalloc(session->pool, session->hd_scratch.max_len + 1);
+    session->hd_scratch.value =
+        apr_pcalloc(session->pool, session->hd_scratch.max_len + 1);
+
     session->padding_max = h2_config_sgeti(s, H2_CONF_PADDING_BITS);
     if (session->padding_max) {
         session->padding_max = (0x01 << session->padding_max) - 1; 
@@ -997,7 +1021,7 @@ apr_status_t h2_session_create(h2_session **psession, conn_rec *c, request_rec *
     
     n = h2_config_sgeti(s, H2_CONF_PUSH_DIARY_SIZE);
     session->push_diary = h2_push_diary_create(session->pool, n);
-    
+
     if (APLOGcdebug(c)) {
         ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, 
                       H2_SSSN_LOG(APLOGNO(03200), session, 
@@ -1665,9 +1689,10 @@ static void on_stream_state_enter(void *ctx, h2_stream *stream)
             break;
         case H2_SS_CLEANUP:
             nghttp2_session_set_stream_user_data(session->ngh2, stream->id, NULL);
+            update_child_status(session, SERVER_BUSY_WRITE, "done", stream);
             h2_mplx_c1_stream_cleanup(session->mplx, stream, &session->open_streams);
+            stream = NULL;
             ++session->streams_done;
-            update_child_status(session, SERVER_BUSY_WRITE, "done", stream);
             break;
         default:
             break;
diff --git a/modules/http2/h2_session.h b/modules/http2/h2_session.h
index 3328509de8..3c0b5c3d71 100644
--- a/modules/http2/h2_session.h
+++ b/modules/http2/h2_session.h
@@ -29,6 +29,7 @@
  */
 
 #include "h2.h"
+#include "h2_util.h"
 
 struct apr_thread_mutext_t;
 struct apr_thread_cond_t;
@@ -118,6 +119,8 @@ typedef struct h2_session {
     struct h2_iqueue *out_c1_blocked;  /* all streams with output blocked on c1 buffer full */
     struct h2_iqueue *ready_to_process;  /* all streams ready for processing */
 
+    h2_hd_scratch hd_scratch;
+
 } h2_session;
 
 const char *h2_session_state_str(h2_session_state state);
diff --git a/modules/http2/h2_stream.c b/modules/http2/h2_stream.c
index ee87555f9f..25af3a4b39 100644
--- a/modules/http2/h2_stream.c
+++ b/modules/http2/h2_stream.c
@@ -659,7 +659,8 @@ apr_status_t h2_stream_set_request_rec(h2_stream *stream,
     if (stream->rst_error) {
         return APR_ECONNRESET;
     }
-    status = h2_request_rcreate(&req, stream->pool, r);
+    status = h2_request_rcreate(&req, stream->pool, r,
+                                &stream->session->hd_scratch);
     if (status == APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, 
                       H2_STRM_LOG(APLOGNO(03058), stream, 
@@ -691,13 +692,11 @@ static void set_error_response(h2_stream *stream, int http_status)
 static apr_status_t add_trailer(h2_stream *stream,
                                 const char *name, size_t nlen,
                                 const char *value, size_t vlen,
-                                size_t max_field_len, int *pwas_added)
+                                h2_hd_scratch *scratch)
 {
     conn_rec *c = stream->session->c1;
-    char *hname, *hvalue;
     const char *existing;
 
-    *pwas_added = 0;
     if (nlen == 0 || name[0] == ':') {
         ap_log_cerror(APLOG_MARK, APLOG_DEBUG, APR_EINVAL, c, 
                       H2_STRM_LOG(APLOGNO(03060), stream, 
@@ -710,20 +709,35 @@ static apr_status_t add_trailer(h2_stream *stream,
     if (!stream->trailers_in) {
         stream->trailers_in = apr_table_make(stream->pool, 5);
     }
-    hname = apr_pstrndup(stream->pool, name, nlen);
-    h2_util_camel_case_header(hname, nlen);
-    existing = apr_table_get(stream->trailers_in, hname);
-    if (max_field_len 
-        && ((existing? strlen(existing)+2 : 0) + vlen + nlen + 2 > max_field_len)) {
-        /* "key: (oldval, )?nval" is too long */
+
+    if (((nlen + vlen + 2) > scratch->max_len))
         return APR_EINVAL;
+
+    /* We need 0-terminated strings to operate on apr_table */
+    AP_DEBUG_ASSERT(nlen < scratch->max_len);
+    memcpy(scratch->name, name, nlen);
+    scratch->name[nlen] = 0;
+    AP_DEBUG_ASSERT(vlen < scratch->max_len);
+    memcpy(scratch->value, value, vlen);
+    scratch->value[vlen] = 0;
+
+    existing = apr_table_get(stream->trailers_in, scratch->name);
+    if(existing) {
+      if (!vlen) /* not adding a 0-length value to existing */
+          return APR_SUCCESS;
+      if ((strlen(existing) + 2 + vlen + nlen + 2 > scratch->max_len)) {
+          /* "name: existing, value" is too long */
+          return APR_EINVAL;
+      }
+      apr_table_merge(stream->trailers_in, scratch->name, scratch->value);
     }
-    if (!existing) *pwas_added = 1;
-    hvalue = apr_pstrndup(stream->pool, value, vlen);
-    apr_table_mergen(stream->trailers_in, hname, hvalue);
-    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, c, 
-                  H2_STRM_MSG(stream, "added trailer '%s: %s'"), hname, hvalue);
-    
+    else {
+        h2_util_camel_case_header(scratch->name, nlen);
+        apr_table_set(stream->trailers_in, scratch->name, scratch->value);
+    }
+    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, c,
+                  H2_STRM_MSG(stream, "added trailer '%s: %s'"),
+                  scratch->name, scratch->value);
     return APR_SUCCESS;
 }
 
@@ -732,7 +746,7 @@ apr_status_t h2_stream_add_header(h2_stream *stream,
                                   const char *value, size_t vlen)
 {
     h2_session *session = stream->session;
-    int error = 0, was_added = 0;
+    int error = 0;
     apr_status_t status = APR_SUCCESS;
     
     H2_STRM_ASSERT_MAGIC(stream, H2_STRM_MAGIC_OK);
@@ -760,13 +774,14 @@ apr_status_t h2_stream_add_header(h2_stream *stream,
         ++stream->request_headers_added;
     }
     else if (H2_SS_IDLE == stream->state) {
+        int was_added;
         if (!stream->rtmp) {
             stream->rtmp = h2_request_create(stream->id, stream->pool,
                                              NULL, NULL, NULL, NULL, NULL);
         }
         status = h2_request_add_header(stream->rtmp, stream->pool,
                                        name, nlen, value, vlen,
-                                       session->s->limit_req_fieldsize, &was_added);
+                                       &session->hd_scratch, &was_added);
         ap_log_cerror(APLOG_MARK, APLOG_TRACE2, status, session->c1,
                       H2_STRM_MSG(stream, "add_header: '%.*s: %.*s"),
                       (int)nlen, name, (int)vlen, value);
@@ -774,8 +789,8 @@ apr_status_t h2_stream_add_header(h2_stream *stream,
     }
     else if (H2_SS_OPEN == stream->state) {
         status = add_trailer(stream, name, nlen, value, vlen,
-                             session->s->limit_req_fieldsize, &was_added);
-        if (was_added) ++stream->request_headers_added;
+                             &session->hd_scratch);
+        if (!status) ++stream->request_headers_added;
     }
     else {
         status = APR_EINVAL;
@@ -784,16 +799,17 @@ apr_status_t h2_stream_add_header(h2_stream *stream,
     
     if (APR_EINVAL == status) {
         /* header too long */
-        if (!h2_stream_is_ready(stream)) {
+        if (!h2_stream_is_ready(stream) && !stream->request_headers_failed) {
             ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, session->c1,
-                          H2_STRM_LOG(APLOGNO(10180), stream,"Request header exceeds "
-                                      "LimitRequestFieldSize: %.*s"),
+                          H2_STRM_LOG(APLOGNO(10180), stream,
+                          "Request header exceeds LimitRequestFieldSize(%d): %.*s"),
+                          (int)session->hd_scratch.max_len,
                           (int)H2MIN(nlen, 80), name);
         }
         error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;
         goto cleanup;
     }
-    
+
     if (session->s->limit_req_fields > 0 
         && stream->request_headers_added > session->s->limit_req_fields) {
         /* too many header lines */
@@ -805,12 +821,13 @@ apr_status_t h2_stream_add_header(h2_stream *stream,
         if (!h2_stream_is_ready(stream)) {
             ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, session->c1,
                           H2_STRM_LOG(APLOGNO(10181), stream, "Number of request headers "
-                                      "exceeds LimitRequestFields"));
+                                      "exceeds LimitRequestFields(%d)"),
+                                      (int)session->s->limit_req_fields);
         }
         error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;
         goto cleanup;
     }
-    
+
 cleanup:
     if (error) {
         ++stream->request_headers_failed;
diff --git a/modules/http2/h2_util.c b/modules/http2/h2_util.c
index 8e53cebdf9..605c348ca1 100644
--- a/modules/http2/h2_util.c
+++ b/modules/http2/h2_util.c
@@ -1693,10 +1693,9 @@ int h2_ignore_resp_trailer(const char *name, size_t len)
 }
 
 static apr_status_t req_add_header(apr_table_t *headers, apr_pool_t *pool,
-                                   nghttp2_nv *nv, size_t max_field_len,
+                                   nghttp2_nv *nv, h2_hd_scratch *scratch,
                                    int *pwas_added)
 {
-    char *hname, *hvalue;
     const char *existing;
 
     *pwas_added = 0;
@@ -1712,15 +1711,14 @@ static apr_status_t req_add_header(apr_table_t *headers, apr_pool_t *pool,
             /* Cookie header come separately in HTTP/2, but need
              * to be merged by "; " (instead of default ", ")
              */
-            if (max_field_len
-                && strlen(existing) + nv->valuelen + nv->namelen + 4
-                   > max_field_len) {
+            if ((strlen(existing) + nv->valuelen + nv->namelen + 4)
+                   > scratch->max_len) {
                 /* "key: oldval, nval" is too long */
                 return APR_EINVAL;
             }
-            hvalue = apr_pstrndup(pool, (const char*)nv->value, nv->valuelen);
             apr_table_setn(headers, "Cookie",
-                           apr_psprintf(pool, "%s; %s", existing, hvalue));
+                           apr_psprintf(pool, "%s; %.*s", existing,
+                                        (int)nv->valuelen, nv->value));
             return APR_SUCCESS;
         }
     }
@@ -1731,27 +1729,40 @@ static apr_status_t req_add_header(apr_table_t *headers, apr_pool_t *pool,
         }
     }
 
-    hname = apr_pstrndup(pool, (const char*)nv->name, nv->namelen);
-    h2_util_camel_case_header(hname, nv->namelen);
-    existing = apr_table_get(headers, hname);
-    if (max_field_len) {
-        if ((existing? strlen(existing)+2 : 0) + nv->valuelen + nv->namelen + 2
-            > max_field_len) {
-            /* "key: (oldval, )?nval" is too long */
+    if (((nv->namelen + nv->valuelen + 2) > scratch->max_len))
+        return APR_EINVAL;
+
+    /* We need 0-terminated strings to operate on apr_table */
+    AP_DEBUG_ASSERT(nv->namelen < scratch->max_len);
+    memcpy(scratch->name, nv->name, nv->namelen);
+    scratch->name[nv->namelen] = 0;
+    AP_DEBUG_ASSERT(nv->valuelen < scratch->max_len);
+    memcpy(scratch->value, nv->value, nv->valuelen);
+    scratch->value[nv->valuelen] = 0;
+
+    *pwas_added = 1;
+    existing = apr_table_get(headers, scratch->name);
+    if (existing) {
+        if (!nv->valuelen) /* not adding a 0-length value to existing */
+            return APR_SUCCESS;
+        if ((strlen(existing) + 2 + nv->valuelen + nv->namelen + 2)
+            > scratch->max_len) {
+            /* "name: existing, value" is too long */
             return APR_EINVAL;
         }
+        apr_table_merge(headers, scratch->name, scratch->value);
+    }
+    else {
+        h2_util_camel_case_header(scratch->name, nv->namelen);
+        apr_table_set(headers, scratch->name, scratch->value);
     }
-    if (!existing) *pwas_added = 1;
-    hvalue = apr_pstrndup(pool, (const char*)nv->value, nv->valuelen);
-    apr_table_mergen(headers, hname, hvalue);
-
     return APR_SUCCESS;
 }
 
 apr_status_t h2_req_add_header(apr_table_t *headers, apr_pool_t *pool,
                               const char *name, size_t nlen,
                               const char *value, size_t vlen,
-                              size_t max_field_len, int *pwas_added)
+                              h2_hd_scratch *scratch, int *pwas_added)
 {
     nghttp2_nv nv;
 
@@ -1759,7 +1770,7 @@ apr_status_t h2_req_add_header(apr_table_t *headers, apr_pool_t *pool,
     nv.namelen = nlen;
     nv.value = (uint8_t*)value;
     nv.valuelen = vlen;
-    return req_add_header(headers, pool, &nv, max_field_len, pwas_added);
+    return req_add_header(headers, pool, &nv, scratch, pwas_added);
 }
 
 /*******************************************************************************
diff --git a/modules/http2/h2_util.h b/modules/http2/h2_util.h
index d2e6548ba8..c2cab4afa4 100644
--- a/modules/http2/h2_util.h
+++ b/modules/http2/h2_util.h
@@ -397,14 +397,21 @@ apr_status_t h2_req_create_ngheader(h2_ngheader **ph, apr_pool_t *p,
                                     const struct h2_request *req);
 #endif
 
+typedef struct h2_hd_scratch {
+    size_t max_len; /* header field size name + ': ' + value */
+    char *name;     /* max_len+1 sized */
+    char *value;    /* max_len+1 sized */
+
+} h2_hd_scratch;
+
 /**
  * Add a HTTP/2 header and return the table key if it really was added
  * and not ignored.
  */
-apr_status_t h2_req_add_header(apr_table_t *headers, apr_pool_t *pool, 
+apr_status_t h2_req_add_header(apr_table_t *headers, apr_pool_t *pool,
                                const char *name, size_t nlen,
                                const char *value, size_t vlen,
-                               size_t max_field_len, int *pwas_added);
+                               h2_hd_scratch *scratch, int *pwas_added);
 
 /*******************************************************************************
  * apr brigade helpers
diff --git a/test/modules/http2/test_200_header_invalid.py b/test/modules/http2/test_200_header_invalid.py
index 04c022c362..0aa6c3ad51 100644
--- a/test/modules/http2/test_200_header_invalid.py
+++ b/test/modules/http2/test_200_header_invalid.py
@@ -132,7 +132,7 @@ class TestInvalidHeaders:
         assert 431 == r.response["status"]
 
     # test header field count, LimitRequestFields (default 100)
-    # see #201: several headers with same name are mered and count only once
+    # see #201: several headers with same name are merged and counted
     def test_h2_200_12(self, env):
         url = env.mkurl("https", "cgi", "/")
         opt = []
@@ -142,7 +142,7 @@ class TestInvalidHeaders:
         r = env.curl_get(url, options=opt)
         assert r.response["status"] == 200
         r = env.curl_get(url, options=(opt + ["-H", "y: 2"]))
-        assert r.response["status"] == 200
+        assert r.response["status"] == 431
 
     # test header field count, LimitRequestFields (default 100)
     # different header names count each
-- 
2.43.0

