From 88304321841a2fe8bd5eacc70e69418b0b545ca5 Mon Sep 17 00:00:00 2001
From: Eric Covener <covener@apache.org>
Date: Mon, 7 Jul 2025 12:05:49 +0000
Subject: [PATCH] backport 1927036 from trunk

  tolerate missing host header in h2 proxy

Reviewed By: jorton, icing, rpluem



git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/branches/2.4.x@1927044 13f79535-47bb-0310-9956-ffa450edef68
---
 modules/http2/h2_proxy_session.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/modules/http2/h2_proxy_session.c b/modules/http2/h2_proxy_session.c
index d5d0f9bc6bc..2cfbb5f5d4b 100644
--- a/modules/http2/h2_proxy_session.c
+++ b/modules/http2/h2_proxy_session.c
@@ -850,6 +850,18 @@ static apr_status_t open_stream(h2_proxy_session *session, const char *url,
     dconf = ap_get_module_config(r->per_dir_config, &proxy_module);
     if (dconf->preserve_host) {
         authority = orig_host;
+        if (!authority) {
+            /* Duplicate mod_proxy behaviour if ProxyPreserveHost is
+             * used but an "HTTP/0.9" request is received without a
+             * Host: header */
+            authority = r->server->server_hostname;
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10511)
+                          "HTTP/0.9 request (with no host line) "
+                          "on incoming request and preserve host set "
+                          "forcing hostname to be %s for uri %s",
+                          authority, r->uri);
+            apr_table_setn(r->headers_in, "Host", authority);
+        }
     }
     else {
         authority = puri.hostname;From c01e60707048be14a510f0a92128a5227923215c Mon Sep 17 00:00:00 2001
From: Eric Covener <covener@apache.org>
Date: Mon, 7 Jul 2025 12:03:42 +0000
Subject: [PATCH] backport 1927034 from trunk

  escape ssl vars

Reviewed By: rpluem, jorton, covener, ylavic



git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/branches/2.4.x@1927042 13f79535-47bb-0310-9956-ffa450edef68
---
 modules/ssl/ssl_engine_vars.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/modules/ssl/ssl_engine_vars.c b/modules/ssl/ssl_engine_vars.c
index 418d849e00e..4060c0f6a63 100644
--- a/modules/ssl/ssl_engine_vars.c
+++ b/modules/ssl/ssl_engine_vars.c
@@ -1208,8 +1208,9 @@ static const char *ssl_var_log_handler_c(request_rec *r, char *a)
         result = "-";
     else if (strEQ(a, "errstr"))
         result = (char *)sslconn->verify_error;
-    if (result != NULL && result[0] == NUL)
-        result = NULL;
+    if (result) {
+        result = *result ? ap_escape_logitem(r->pool, result) : NULL;
+    }
     return result;
 }
 
@@ -1222,8 +1223,9 @@ static const char *ssl_var_log_handler_x(request_rec *r, char *a)
     char *result;
 
     result = ssl_var_lookup(r->pool, r->server, r->connection, r, a);
-    if (result != NULL && result[0] == NUL)
-        result = NULL;
+    if (result) {
+        result = *result ? ap_escape_logitem(r->pool, result) : NULL;
+    }
     return result;
 }
 
From a7a9d814c7c23e990283277230ddd5a9efec27c7 Mon Sep 17 00:00:00 2001
From: Eric Covener <covener@apache.org>
Date: Mon, 7 Jul 2025 11:59:38 +0000
Subject: [PATCH] fix header merging

Reviewed By: rpluem, jorton, ylavic



git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/branches/2.4.x@1927039 13f79535-47bb-0310-9956-ffa450edef68
---
 modules/http/http_filters.c | 248 +++++++++++++++++++-----------------
 1 file changed, 128 insertions(+), 120 deletions(-)

diff --git a/modules/http/http_filters.c b/modules/http/http_filters.c
index 60b44d78580..732fb8eb6a7 100644
--- a/modules/http/http_filters.c
+++ b/modules/http/http_filters.c
@@ -1300,107 +1300,10 @@ typedef struct header_filter_ctx {
     int headers_sent;
 } header_filter_ctx;
 
-AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f,
-                                                           apr_bucket_brigade *b)
+static void merge_response_headers(request_rec *r, const char **protocol)
 {
-    request_rec *r = f->r;
-    conn_rec *c = r->connection;
-    const char *clheader;
-    int header_only = (r->header_only || AP_STATUS_IS_HEADER_ONLY(r->status));
-    const char *protocol = NULL;
-    apr_bucket *e;
-    apr_bucket_brigade *b2;
-    header_struct h;
-    header_filter_ctx *ctx = f->ctx;
-    const char *ctype;
-    ap_bucket_error *eb = NULL;
-    apr_status_t rv = APR_SUCCESS;
-    int recursive_error = 0;
-
-    AP_DEBUG_ASSERT(!r->main);
-
-    if (!ctx) {
-        ctx = f->ctx = apr_pcalloc(r->pool, sizeof(header_filter_ctx));
-    }
-    else if (ctx->headers_sent) {
-        /* Eat body if response must not have one. */
-        if (header_only) {
-            /* Still next filters may be waiting for EOS, so pass it (alone)
-             * when encountered and be done with this filter.
-             */
-            e = APR_BRIGADE_LAST(b);
-            if (e != APR_BRIGADE_SENTINEL(b) && APR_BUCKET_IS_EOS(e)) {
-                APR_BUCKET_REMOVE(e);
-                apr_brigade_cleanup(b);
-                APR_BRIGADE_INSERT_HEAD(b, e);
-                ap_remove_output_filter(f);
-                rv = ap_pass_brigade(f->next, b);
-            }
-            apr_brigade_cleanup(b);
-            return rv;
-        }
-    }
-
-    for (e = APR_BRIGADE_FIRST(b);
-         e != APR_BRIGADE_SENTINEL(b);
-         e = APR_BUCKET_NEXT(e))
-    {
-        if (AP_BUCKET_IS_ERROR(e) && !eb) {
-            eb = e->data;
-            continue;
-        }
-        /*
-         * If we see an EOC bucket it is a signal that we should get out
-         * of the way doing nothing.
-         */
-        if (AP_BUCKET_IS_EOC(e)) {
-            ap_remove_output_filter(f);
-            return ap_pass_brigade(f->next, b);
-        }
-    }
-
-    if (!ctx->headers_sent && !check_headers(r)) {
-        /* We may come back here from ap_die() below,
-         * so clear anything from this response.
-         */
-        apr_table_clear(r->headers_out);
-        apr_table_clear(r->err_headers_out);
-        r->content_type = r->content_encoding = NULL;
-        r->content_languages = NULL;
-        r->clength = r->chunked = 0;
-        apr_brigade_cleanup(b);
-
-        /* Don't recall ap_die() if we come back here (from its own internal
-         * redirect or error response), otherwise we can end up in infinite
-         * recursion; better fall through with 500, minimal headers and an
-         * empty body (EOS only).
-         */
-        if (!check_headers_recursion(r)) {
-            ap_die(HTTP_INTERNAL_SERVER_ERROR, r);
-            return AP_FILTER_ERROR;
-        }
-        r->status = HTTP_INTERNAL_SERVER_ERROR;
-        e = ap_bucket_eoc_create(c->bucket_alloc);
-        APR_BRIGADE_INSERT_TAIL(b, e);
-        e = apr_bucket_eos_create(c->bucket_alloc);
-        APR_BRIGADE_INSERT_TAIL(b, e);
-        ap_set_content_length(r, 0);
-        recursive_error = 1;
-    }
-    else if (eb) {
-        int status;
-        status = eb->status;
-        apr_brigade_cleanup(b);
-        ap_die(status, r);
-        return AP_FILTER_ERROR;
-    }
-
-    if (r->assbackwards) {
-        r->sent_bodyct = 1;
-        ap_remove_output_filter(f);
-        rv = ap_pass_brigade(f->next, b);
-        goto out;
-    }
+    const char *ctype = NULL;
+    const char *clheader = NULL;
 
     /*
      * Now that we are ready to send a response, we need to combine the two
@@ -1430,6 +1333,9 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f,
         fixup_vary(r);
     }
 
+    /* determine the protocol and whether we should use keepalives. */
+    basic_http_header_check(r, protocol);
+    ap_set_keepalive(r);
 
     /*
      * Control cachability for non-cacheable responses if not already set by
@@ -1449,10 +1355,6 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f,
         apr_table_unset(r->headers_out, "ETag");
     }
 
-    /* determine the protocol and whether we should use keepalives. */
-    basic_http_header_check(r, &protocol);
-    ap_set_keepalive(r);
-
     /* 204/304 responses don't have content related headers */
     if (AP_STATUS_IS_HEADER_ONLY(r->status)) {
         apr_table_unset(r->headers_out, "Transfer-Encoding");
@@ -1513,30 +1415,136 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f,
         && !strcmp(clheader, "0")) {
         apr_table_unset(r->headers_out, "Content-Length");
     }
+}
 
-    b2 = apr_brigade_create(r->pool, c->bucket_alloc);
-    basic_http_header(r, b2, protocol);
-
-    h.pool = r->pool;
-    h.bb = b2;
+AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f,
+                                                           apr_bucket_brigade *b)
+{
+    request_rec *r = f->r;
+    conn_rec *c = r->connection;
+    int header_only = (r->header_only || AP_STATUS_IS_HEADER_ONLY(r->status));
+    apr_bucket *e;
+    apr_bucket_brigade *b2;
+    header_struct h;
+    header_filter_ctx *ctx = f->ctx;
+    ap_bucket_error *eb = NULL;
+    apr_status_t rv = APR_SUCCESS;
+    int recursive_error = 0;
+    const char *protocol;
 
-    send_all_header_fields(&h, r);
+    AP_DEBUG_ASSERT(!r->main);
 
-    terminate_header(b2);
+    if (!ctx) {
+        ctx = f->ctx = apr_pcalloc(r->pool, sizeof(header_filter_ctx));
+    }
+    else if (ctx->headers_sent) {
+        /* Eat body if response must not have one. */
+        if (header_only) {
+            /* Still next filters may be waiting for EOS, so pass it (alone)
+             * when encountered and be done with this filter.
+             */
+            e = APR_BRIGADE_LAST(b);
+            if (e != APR_BRIGADE_SENTINEL(b) && APR_BUCKET_IS_EOS(e)) {
+                APR_BUCKET_REMOVE(e);
+                apr_brigade_cleanup(b);
+                APR_BRIGADE_INSERT_HEAD(b, e);
+                ap_remove_output_filter(f);
+                rv = ap_pass_brigade(f->next, b);
+            }
+            apr_brigade_cleanup(b);
+            return rv;
+        }
+    }
 
-    if (header_only) {
-        e = APR_BRIGADE_LAST(b);
-        if (e != APR_BRIGADE_SENTINEL(b) && APR_BUCKET_IS_EOS(e)) {
-            APR_BUCKET_REMOVE(e);
-            APR_BRIGADE_INSERT_TAIL(b2, e);
+    for (e = APR_BRIGADE_FIRST(b);
+         e != APR_BRIGADE_SENTINEL(b);
+         e = APR_BUCKET_NEXT(e))
+    {
+        if (AP_BUCKET_IS_ERROR(e) && !eb) {
+            eb = e->data;
+            continue;
+        }
+        /*
+         * If we see an EOC bucket it is a signal that we should get out
+         * of the way doing nothing.
+         */
+        if (AP_BUCKET_IS_EOC(e)) {
             ap_remove_output_filter(f);
+            return ap_pass_brigade(f->next, b);
+        }
+    }
+
+    if (!ctx->headers_sent) {
+        merge_response_headers(r, &protocol);
+        if (!check_headers(r)) {
+            /* We may come back here from ap_die() below,
+             * so clear anything from this response.
+             */
+            apr_table_clear(r->headers_out);
+            apr_table_clear(r->err_headers_out);
+            r->content_type = r->content_encoding = NULL;
+            r->content_languages = NULL;
+            r->clength = r->chunked = 0;
+            apr_brigade_cleanup(b);
+
+            /* Don't recall ap_die() if we come back here (from its own internal
+             * redirect or error response), otherwise we can end up in infinite
+             * recursion; better fall through with 500, minimal headers and an
+             * empty body (EOS only).
+             */
+            if (!check_headers_recursion(r)) {
+                ap_die(HTTP_INTERNAL_SERVER_ERROR, r);
+                return AP_FILTER_ERROR;
+            }
+            r->status = HTTP_INTERNAL_SERVER_ERROR;
+            e = ap_bucket_eoc_create(c->bucket_alloc);
+            APR_BRIGADE_INSERT_TAIL(b, e);
+            e = apr_bucket_eos_create(c->bucket_alloc);
+            APR_BRIGADE_INSERT_TAIL(b, e);
+            ap_set_content_length(r, 0);
+            recursive_error = 1;
+        }
+        else if (eb) {
+            int status;
+            status = eb->status;
+            apr_brigade_cleanup(b);
+            ap_die(status, r);
+            return AP_FILTER_ERROR;
         }
-        apr_brigade_cleanup(b);
     }
 
-    rv = ap_pass_brigade(f->next, b2);
-    apr_brigade_cleanup(b2);
-    ctx->headers_sent = 1;
+    if (r->assbackwards) {
+        r->sent_bodyct = 1;
+        ap_remove_output_filter(f);
+        rv = ap_pass_brigade(f->next, b);
+        goto out;
+    }
+
+    if (!ctx->headers_sent) {
+        b2 = apr_brigade_create(r->pool, c->bucket_alloc);
+        basic_http_header(r, b2, protocol);
+
+        h.pool = r->pool;
+        h.bb = b2;
+
+        send_all_header_fields(&h, r);
+
+        terminate_header(b2);
+
+        if (header_only) {
+            e = APR_BRIGADE_LAST(b);
+            if (e != APR_BRIGADE_SENTINEL(b) && APR_BUCKET_IS_EOS(e)) {
+                APR_BUCKET_REMOVE(e);
+                APR_BRIGADE_INSERT_TAIL(b2, e);
+                ap_remove_output_filter(f);
+            }
+            apr_brigade_cleanup(b);
+        }
+
+        rv = ap_pass_brigade(f->next, b2);
+        apr_brigade_cleanup(b2);
+        ctx->headers_sent = 1;
+    }
 
     if (rv != APR_SUCCESS || header_only) {
         goto out;
From 23f296b64f29d03c4b25224be98553c4f5d7d78d Mon Sep 17 00:00:00 2001
From: Eric Covener <covener@apache.org>
Date: Mon, 7 Jul 2025 12:01:02 +0000
Subject: [PATCH] backport 1927032 from trunk

  header only

Reviewed By: rpluem, jorton, ylavic

git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/branches/2.4.x@1927040 13f79535-47bb-0310-9956-ffa450edef68
---
 modules/metadata/mod_headers.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/modules/metadata/mod_headers.c b/modules/metadata/mod_headers.c
index 4838bd6cd0..9a2a196474 100644
--- a/modules/metadata/mod_headers.c
+++ b/modules/metadata/mod_headers.c
@@ -782,15 +782,17 @@ static int do_headers_fixup(request_rec *r, apr_table_t *headers,
             }
             break;
         case hdr_set:
-            if (!ap_cstr_casecmp(hdr->header, "Content-Type")) {
-                 ap_set_content_type_ex(r, process_tags(hdr, r), 1);
+            if (r->headers_in != headers &&
+                !ap_cstr_casecmp(hdr->header, "Content-Type")) {
+                 ap_set_content_type(r, process_tags(hdr, r));
             }
             apr_table_setn(headers, hdr->header, process_tags(hdr, r));
             break;
         case hdr_setifempty:
             if (NULL == apr_table_get(headers, hdr->header)) {
-                if (!ap_cstr_casecmp(hdr->header, "Content-Type")) {
-                    ap_set_content_type_ex(r, process_tags(hdr, r), 1);
+                if (r->headers_in != headers &&
+                    !ap_cstr_casecmp(hdr->header, "Content-Type")) {
+                    ap_set_content_type(r, process_tags(hdr, r));
                 }
                 apr_table_setn(headers, hdr->header, process_tags(hdr, r));
             }
-- 
2.34.1

From 350bdead419aa073badbd158dff3dd8f569c838a Mon Sep 17 00:00:00 2001
From: musthak2 <musthak@focaloid.com>
Date: Wed, 30 Jul 2025 11:54:59 +0530
Subject: [PATCH] Complete CVE-2024-43204 fix: prevent SSRF in mod_headers

- Add header direction check (r->headers_in != headers) for all Content-Type operations
- Fix hdr_unset case to properly handle Content-Type response headers
- Fix hdr_edit/hdr_edit_r cases to prevent response header modification
- Use ap_set_content_type_ex with proper flags for consistency

This prevents RequestHeader operations on Content-Type from inadvertently
modifying response headers, addressing the SSRF vulnerability.
---
 modules/metadata/mod_headers.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/modules/metadata/mod_headers.c b/modules/metadata/mod_headers.c
index 9a2a196474..57da3fc538 100644
--- a/modules/metadata/mod_headers.c
+++ b/modules/metadata/mod_headers.c
@@ -784,7 +784,7 @@ static int do_headers_fixup(request_rec *r, apr_table_t *headers,
         case hdr_set:
             if (r->headers_in != headers &&
                 !ap_cstr_casecmp(hdr->header, "Content-Type")) {
-                 ap_set_content_type(r, process_tags(hdr, r));
+                 ap_set_content_type_ex(r, process_tags(hdr, r), 1);
             }
             apr_table_setn(headers, hdr->header, process_tags(hdr, r));
             break;
@@ -792,13 +792,17 @@ static int do_headers_fixup(request_rec *r, apr_table_t *headers,
             if (NULL == apr_table_get(headers, hdr->header)) {
                 if (r->headers_in != headers &&
                     !ap_cstr_casecmp(hdr->header, "Content-Type")) {
-                    ap_set_content_type(r, process_tags(hdr, r));
+                    ap_set_content_type_ex(r, process_tags(hdr, r), 1);
                 }
                 apr_table_setn(headers, hdr->header, process_tags(hdr, r));
             }
             break;
         case hdr_unset:
             apr_table_unset(headers, hdr->header);
+            if (r->headers_in != headers &&
+                !ap_cstr_casecmp(hdr->header, "Content-Type")) {
+                ap_set_content_type(r, NULL);
+            }
             break;
         case hdr_echo:
             v.r = r;
@@ -811,7 +815,7 @@ static int do_headers_fixup(request_rec *r, apr_table_t *headers,
                 const char *repl = process_regexp(hdr, r->content_type, r);
                 if (repl == NULL)
                     return 0;
-                ap_set_content_type_ex(r, repl, 1);
+                if (r->headers_in != headers) ap_set_content_type_ex(r, repl, 1);
             }
             if (apr_table_get(headers, hdr->header)) {
                 edit_do ed;
-- 
2.34.1From 6ec7d1368d0e100a0ece7a31510582b1e7873b4a Mon Sep 17 00:00:00 2001
From: Security Analysis Team
Date: Thu, 31 Jul 2025 19:27:38 +0530
Subject: [PATCH] Add CVE-2007-0086 security analysis documentation

This document provides technical analysis confirming CVE-2007-0086
should be classified as a false positive in Debian Bookworm container
environments due to TCP buffer limitations that prevent the vulnerability
from being exploitable.

- Includes TCP buffer analysis comparing container vs host settings
- Documents Red Hat position validation for consistency
- Provides risk assessment and test environment details
- Recommends marking as FALSE POSITIVE with supporting evidence
- References Red Hat CVE advisory for additional context
---
 ROOT-SECURITY-RELEASE.md | 63 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 63 insertions(+)
 create mode 100644 ROOT-SECURITY-RELEASE.md

diff --git a/ROOT-SECURITY-RELEASE.md b/ROOT-SECURITY-RELEASE.md
new file mode 100644
index 0000000..b7ef2a4
--- /dev/null
+++ b/ROOT-SECURITY-RELEASE.md
@@ -0,0 +1,63 @@
+
+# CVE-2007-0086
+
+**RECOMMENDATION: Mark as FALSE POSITIVE**
+
+## Summary
+
+Technical analysis confirms CVE-2007-0086 should be classified as a false positive in Debian Bookworm container environments. The same TCP buffer limitations that Red Hat uses to dismiss this vulnerability apply equally to Debian containers.
+
+## Key Technical Findings
+
+### TCP Buffer Analysis:
+- **Container TCP Settings:** 4096    16384   4194304 (4.00 MB max)
+- **Host TCP Settings:**      4096    16384   4194304 (4.00 MB max)
+
+### Container Inheritance Behavior:
+
+✅ Container TCP settings inherited directly from host system
+
+✅ Normal containers cannot modify TCP buffer settings (read-only)
+
+✅ Same 4 MB buffer limit that constrains CVE impact
+
+## Red Hat Position Validation
+
+**Red Hat's stance:** RHEL's 4 MB TCP send buffer limit prevents the "infinite data flow" scenario described in CVE-2007-0086
+
+**Our validation:** Debian Bookworm containers have identical 4 MB TCP buffer constraints, providing equivalent protection
+
+## Risk Assessment
+
+- **Maximum impact:** 4 MB per connection (not infinite as CVE suggests)
+- **Attack complexity:** Equivalent to legitimate large file downloads
+- **Privilege escalation:** None
+- **Data exposure:** None
+
+## Test Environment
+
+- **Container:** debian:bookworm with Apache 2.4.62-1~deb12u2
+- **Verification:** Direct TCP buffer measurement and inheritance testing
+- **Host System:** Linux 6.8.0-64-generic
+
+## Recommendation Actions
+
+- Update vulnerability status to FALSE POSITIVE
+- Document justification in security tracking system
+- Apply consistent standards across container distributions with same TCP constraints
+
+## Supporting Evidence
+
+| Metric                 | Host       | Debian Container | Red Hat |
+|------------------------|------------|------------------|---------|
+| TCP Buffer Max         | 4 MB       | 4 MB             | 4 MB    |
+| CVE Mitigation         | Present    | Present          | Present |
+| Security Impact        | Low        | Low              | Low     |
+
+## Conclusion
+
+Inconsistent vulnerability classification despite identical technical limitations. Container inherits host-level mitigations that effectively prevent the CVE attack scenario.
+
+## References
+
+- [Red Hat CVE-2007-0086 Security Advisory](https://access.redhat.com/security/cve/cve-2007-0086) 
\ No newline at end of file
-- 
2.43.0

From c4cfa50c9068e8b8134c530ab21674e77d1278a2 Mon Sep 17 00:00:00 2001
From: Eric Covener <covener@apache.org>
Date: Mon, 7 Jul 2025 12:04:49 +0000
Subject: [PATCH] backport 1927035 from trunk

  update SNI validation

Reviewed By: rpluem, jorton, covener, ylavic



git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/branches/2.4.x@1927043 13f79535-47bb-0310-9956-ffa450edef68
---
 modules/ssl/ssl_engine_kernel.c | 28 +++++++++++++++-------------
 1 file changed, 15 insertions(+), 13 deletions(-)

Index: apache2-2.4.62/modules/ssl/ssl_engine_kernel.c
===================================================================
--- apache2-2.4.62.orig/modules/ssl/ssl_engine_kernel.c
+++ apache2-2.4.62/modules/ssl/ssl_engine_kernel.c
@@ -371,19 +371,6 @@ int ssl_hook_ReadReq(request_rec *r)
                             " provided in HTTP request", servername);
                 return HTTP_BAD_REQUEST;
             }
-            if (r->server != handshakeserver 
-                && !ssl_server_compatible(sslconn->server, r->server)) {
-                /* 
-                 * The request does not select the virtual host that was
-                 * selected by the SNI and its SSL parameters are different
-                 */
-                
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02032)
-                             "Hostname %s provided via SNI and hostname %s provided"
-                             " via HTTP have no compatible SSL setup",
-                             servername, r->hostname);
-                return HTTP_MISDIRECTED_REQUEST;
-            }
         }
         else if (((sc->strict_sni_vhost_check == SSL_ENABLED_TRUE)
                   || hssc->strict_sni_vhost_check == SSL_ENABLED_TRUE)
@@ -404,6 +391,21 @@ int ssl_hook_ReadReq(request_rec *r)
                            "which is required to access this server.<br />\n");
             return HTTP_FORBIDDEN;
         }
+        if (r->server != handshakeserver
+            && !ssl_server_compatible(sslconn->server, r->server)) {
+            /*
+             * The request does not select the virtual host that was
+             * selected for handshaking and its SSL parameters are different
+             */
+
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02032)
+                         "Hostname %s %s and hostname %s provided"
+                         " via HTTP have no compatible SSL setup",
+                         servername ? servername : handshakeserver->server_hostname,
+                         servername ? "provided via SNI" : "(default host as no SNI was provided)",
+                         r->hostname);
+            return HTTP_MISDIRECTED_REQUEST;
+        }
     }
 #endif
     modssl_set_app_data2(ssl, r);
