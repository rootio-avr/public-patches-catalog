From 9c98370287f4e709924aee7c58ef21c85289a7f0 Mon Sep 17 00:00:00 2001
From: Stig Palmquist <git@stig.io>
Date: Tue, 28 Feb 2023 11:54:06 +0100
Subject: [PATCH] Add verify_SSL=>1 to HTTP::Tiny to verify https server
 identity

---
 lib/CPAN/HTTP/Client.pm | 1 +
 1 file changed, 1 insertion(+)

diff --git a/cpan/CPAN/lib/CPAN/HTTP/Client.pm b/cpan/CPAN/lib/CPAN/HTTP/Client.pm
index 4fc792c26..a616fee20 100644
--- a/cpan/CPAN/lib/CPAN/HTTP/Client.pm
+++ b/cpan/CPAN/lib/CPAN/HTTP/Client.pm
@@ -32,6 +32,7 @@ sub mirror {
 
     my $want_proxy = $self->_want_proxy($uri);
     my $http = HTTP::Tiny->new(
+        verify_SSL => 1,
         $want_proxy ? (proxy => $self->{proxy}) : ()
     );
 
From 46cc57a167482b832e281a69a6f48dd0c17c63e9 Mon Sep 17 00:00:00 2001
Date: Thu, 10 Jul 2025 15:32:37 +0530
Subject: [PATCH] patched

---
 cpan/File-Temp/lib/File/Temp.pm | 20 +++++++++++++++++++-
 1 file changed, 19 insertions(+), 1 deletion(-)

diff --git a/cpan/File-Temp/lib/File/Temp.pm b/cpan/File-Temp/lib/File/Temp.pm
index 570f25a561..385ae18536 100644
--- a/cpan/File-Temp/lib/File/Temp.pm
+++ b/cpan/File-Temp/lib/File/Temp.pm
@@ -672,7 +672,25 @@ sub _is_safe {
   my $err_ref = shift;
 
   # Stat path
-  my @info = stat($path);
+  my @info = lstat($path);
+  my $symlink_test_path = $path;
+  my $symlink_loop_count = 0;
+  while (-l _) {
+    if (++$symlink_loop_count >= 50) {
+      $$err_ref = "50 levels of symlinks encountered at $path";
+      return 0;
+    }
+    if ( $info[4] <= File::Temp->top_system_uid() || $info[4] == $>) {
+      # safe to traverse
+      $symlink_test_path = readlink($symlink_test_path);
+      @info = lstat($symlink_test_path);
+    }
+    else {
+      $$err_ref = "Unsafe symlink at $path";
+      return 0;
+    }
+  }
+
   unless (scalar(@info)) {
     $$err_ref = "stat(path) returned no values";
     return 0;
-- 
2.43.0

From 6e6ee761fd7173ae7cf55d8ce385f15215f12f0f Mon Sep 17 00:00:00 2001
Date: Mon, 2 Jun 2025 11:31:26 +0530
Subject: [PATCH] updatedpatch

---
 Cross/config.sh-arm-linux      |   1 +
 Cross/config.sh-arm-linux-n770 |   1 +
 configure.com                  |   1 +
 plan9/config_sh.sample         |   1 +
 sv.c                           |  91 +----------------------------
 t/op/threads-dirh.t            | 104 +--------------------------------
 win32/config.gc                |   1 +
 win32/config.vc                |   1 +
 8 files changed, 10 insertions(+), 191 deletions(-)

diff --git a/Cross/config.sh-arm-linux b/Cross/config.sh-arm-linux
index f2303707b7..5297874bbc 100644
--- a/Cross/config.sh-arm-linux
+++ b/Cross/config.sh-arm-linux
@@ -211,6 +211,7 @@ d_fd_macros='define'
 d_fd_set='define'
 d_fdclose='undef'
 d_fdim='undef'
+d_fdopendir=undef
 d_fds_bits='undef'
 d_fegetround='define'
 d_ffs='undef'
diff --git a/Cross/config.sh-arm-linux-n770 b/Cross/config.sh-arm-linux-n770
index b1e697f17f..ab5cfe9682 100644
--- a/Cross/config.sh-arm-linux-n770
+++ b/Cross/config.sh-arm-linux-n770
@@ -210,6 +210,7 @@ d_fd_macros='define'
 d_fd_set='define'
 d_fdclose='undef'
 d_fdim='undef'
+d_fdopendir=undef
 d_fds_bits='undef'
 d_fegetround='define'
 d_ffs='undef'
diff --git a/configure.com b/configure.com
index 1ea419785b..d22d6ceae6 100644
--- a/configure.com
+++ b/configure.com
@@ -6213,6 +6213,7 @@ $ WC "d_fd_set='" + d_fd_set + "'"
 $ WC "d_fd_macros='define'"
 $ WC "d_fdclose='undef'"
 $ WC "d_fdim='" + d_fdim + "'"
+$ WC "d_fdopendir='undef'"
 $ WC "d_fds_bits='define'"
 $ WC "d_fegetround='undef'"
 $ WC "d_ffs='undef'"
diff --git a/plan9/config_sh.sample b/plan9/config_sh.sample
index 02b46570c1..47314435c0 100644
--- a/plan9/config_sh.sample
+++ b/plan9/config_sh.sample
@@ -211,6 +211,7 @@ d_fd_macros='undef'
 d_fd_set='undef'
 d_fdclose='undef'
 d_fdim='undef'
+d_fdopendir=undef
 d_fds_bits='undef'
 d_fegetround='undef'
 d_ffs='undef'
diff --git a/sv.c b/sv.c
index 16bba941cb..26807ceef2 100644
--- a/sv.c
+++ b/sv.c
@@ -13700,15 +13700,6 @@ Perl_dirp_dup(pTHX_ DIR *const dp, CLONE_PARAMS *const param)
 {
     DIR *ret;
 
-#if defined(HAS_FCHDIR) && defined(HAS_TELLDIR) && defined(HAS_SEEKDIR)
-    DIR *pwd;
-    const Direntry_t *dirent;
-    char smallbuf[256]; /* XXX MAXPATHLEN, surely? */
-    char *name = NULL;
-    STRLEN len = 0;
-    long pos;
-#endif
-
     PERL_UNUSED_CONTEXT;
     PERL_ARGS_ASSERT_DIRP_DUP;
 
@@ -13720,89 +13711,13 @@ Perl_dirp_dup(pTHX_ DIR *const dp, CLONE_PARAMS *const param)
     if (ret)
         return ret;
 
-#if defined(HAS_FCHDIR) && defined(HAS_TELLDIR) && defined(HAS_SEEKDIR)
+#ifdef HAS_FDOPENDIR
 
     PERL_UNUSED_ARG(param);
 
-    /* create anew */
-
-    /* open the current directory (so we can switch back) */
-    if (!(pwd = PerlDir_open("."))) return (DIR *)NULL;
-
-    /* chdir to our dir handle and open the present working directory */
-    if (fchdir(my_dirfd(dp)) < 0 || !(ret = PerlDir_open("."))) {
-        PerlDir_close(pwd);
-        return (DIR *)NULL;
-    }
-    /* Now we should have two dir handles pointing to the same dir. */
-
-    /* Be nice to the calling code and chdir back to where we were. */
-    /* XXX If this fails, then what? */
-    PERL_UNUSED_RESULT(fchdir(my_dirfd(pwd)));
+    ret = fdopendir(dup(my_dirfd(dp)));
 
-    /* We have no need of the pwd handle any more. */
-    PerlDir_close(pwd);
-
-#ifdef DIRNAMLEN
-# define d_namlen(d) (d)->d_namlen
-#else
-# define d_namlen(d) strlen((d)->d_name)
-#endif
-    /* Iterate once through dp, to get the file name at the current posi-
-       tion. Then step back. */
-    pos = PerlDir_tell(dp);
-    if ((dirent = PerlDir_read(dp))) {
-        len = d_namlen(dirent);
-        if (len > sizeof(dirent->d_name) && sizeof(dirent->d_name) > PTRSIZE) {
-            /* If the len is somehow magically longer than the
-             * maximum length of the directory entry, even though
-             * we could fit it in a buffer, we could not copy it
-             * from the dirent.  Bail out. */
-            PerlDir_close(ret);
-            return (DIR*)NULL;
-        }
-        if (len <= sizeof smallbuf) name = smallbuf;
-        else Newx(name, len, char);
-        Move(dirent->d_name, name, len, char);
-    }
-    PerlDir_seek(dp, pos);
-
-    /* Iterate through the new dir handle, till we find a file with the
-       right name. */
-    if (!dirent) /* just before the end */
-        for(;;) {
-            pos = PerlDir_tell(ret);
-            if (PerlDir_read(ret)) continue; /* not there yet */
-            PerlDir_seek(ret, pos); /* step back */
-            break;
-        }
-    else {
-        const long pos0 = PerlDir_tell(ret);
-        for(;;) {
-            pos = PerlDir_tell(ret);
-            if ((dirent = PerlDir_read(ret))) {
-                if (len == (STRLEN)d_namlen(dirent)
-                    && memEQ(name, dirent->d_name, len)) {
-                    /* found it */
-                    PerlDir_seek(ret, pos); /* step back */
-                    break;
-                }
-                /* else we are not there yet; keep iterating */
-            }
-            else { /* This is not meant to happen. The best we can do is
-                      reset the iterator to the beginning. */
-                PerlDir_seek(ret, pos0);
-                break;
-            }
-        }
-    }
-#undef d_namlen
-
-    if (name && name != smallbuf)
-        Safefree(name);
-#endif
-
-#ifdef WIN32
+#elif defined(WIN32)
     ret = win32_dirp_dup(dp, param);
 #endif
 
diff --git a/t/op/threads-dirh.t b/t/op/threads-dirh.t
index bb4bcfc141..14c399ca19 100644
--- a/t/op/threads-dirh.t
+++ b/t/op/threads-dirh.t
@@ -13,16 +13,12 @@ BEGIN {
      skip_all_if_miniperl("no dynamic loading on miniperl, no threads");
      skip_all("runs out of memory on some EBCDIC") if $ENV{PERL_SKIP_BIG_MEM_TESTS};
 
-     plan(6);
+     plan(1);
 }
 
 use strict;
 use warnings;
 use threads;
-use threads::shared;
-use File::Path;
-use File::Spec::Functions qw 'updir catdir';
-use Cwd 'getcwd';
 
 # Basic sanity check: make sure this does not crash
 fresh_perl_is <<'# this is no comment', 'ok', {}, 'crash when duping dirh';
@@ -31,101 +27,3 @@ fresh_perl_is <<'# this is no comment', 'ok', {}, 'crash when duping dirh';
    async{}->join for 1..2;
    print "ok";
 # this is no comment
-
-my $dir;
-SKIP: {
- skip "telldir or seekdir not defined on this platform", 5
-    if !$Config::Config{d_telldir} || !$Config::Config{d_seekdir};
- my $skip = sub {
-   chdir($dir);
-   chdir updir;
-   skip $_[0], 5
- };
-
- if(!$Config::Config{d_fchdir} && $^O ne "MSWin32") {
-  $::TODO = 'dir handle cloning currently requires fchdir on non-Windows platforms';
- }
-
- my @w :shared; # warnings accumulator
- local $SIG{__WARN__} = sub { push @w, $_[0] };
-
- $dir = catdir getcwd(), "thrext$$" . int rand() * 100000;
-
- rmtree($dir) if -d $dir;
- mkdir($dir);
-
- # Create a dir structure like this:
- #   $dir
- #     |
- #     `- toberead
- #            |
- #            +---- thrit
- #            |
- #            +---- rile
- #            |
- #            `---- zor
-
- chdir($dir);
- mkdir 'toberead';
- chdir 'toberead';
- {open my $fh, ">thrit" or &$skip("Cannot create file thrit")}
- {open my $fh, ">rile" or &$skip("Cannot create file rile")}
- {open my $fh, ">zor" or &$skip("Cannot create file zor")}
- chdir updir;
-
- # Then test that dir iterators are cloned correctly.
-
- opendir my $toberead, 'toberead';
- my $start_pos = telldir $toberead;
- my @first_2 = (scalar readdir $toberead, scalar readdir $toberead);
- my @from_thread = @{; async { [readdir $toberead ] } ->join };
- my @from_main = readdir $toberead;
- is join('-', sort @from_thread), join('-', sort @from_main),
-     'dir iterator is copied from one thread to another';
- like
-   join('-', "", sort(@first_2, @from_thread), ""),
-   qr/(?<!-rile)-rile-thrit-zor-(?!zor-)/i,
-  'cloned iterator iterates exactly once over everything not already seen';
-
- seekdir $toberead, $start_pos;
- readdir $toberead for 1 .. @first_2+@from_thread;
- {
-  local $::TODO; # This always passes when dir handles are not cloned.
-  is
-    async { readdir $toberead // 'undef' } ->join, 'undef',
-   'cloned dir iterator that points to the end of the directory'
-  ;
- }
-
- # Make sure the cloning code can handle file names longer than 255 chars
- SKIP: {
-  chdir 'toberead';
-  open my $fh,
-    ">floccipaucinihilopilification-"
-   . "pneumonoultramicroscopicsilicovolcanoconiosis-"
-   . "lopadotemachoselachogaleokranioleipsanodrimypotrimmatosilphiokarabo"
-   . "melitokatakechymenokichlepikossyphophattoperisteralektryonoptokephal"
-   . "liokinklopeleiolagoiosiraiobaphetraganopterygon"
-    or
-     chdir updir,
-     skip("OS does not support long file names (and I mean *long*)", 1);
-  chdir updir;
-  opendir my $dirh, "toberead";
-  my $test_name
-    = "dir iterators can be cloned when the next fn > 255 chars";
-  while() {
-   my $pos = telldir $dirh;
-   my $fn = readdir($dirh);
-   if(!defined $fn) { fail($test_name); last SKIP; }
-   if($fn =~ 'lagoio') { 
-    seekdir $dirh, $pos;
-    last;
-   }
-  }
-  is length async { scalar readdir $dirh } ->join, 258, $test_name;
- }
-
- is scalar @w, 0, 'no warnings during all that' or diag @w;
- chdir updir;
-}
-rmtree($dir);
diff --git a/win32/config.gc b/win32/config.gc
index 271627a2d2..87421e98a4 100644
--- a/win32/config.gc
+++ b/win32/config.gc
@@ -198,6 +198,7 @@ d_fd_macros='define'
 d_fd_set='define'
 d_fdclose='undef'
 d_fdim='undef'
+d_fdopendir='undef'
 d_fds_bits='define'
 d_fegetround='undef'
 d_ffs='undef'
diff --git a/win32/config.vc b/win32/config.vc
index ced877942a..c78264118c 100644
--- a/win32/config.vc
+++ b/win32/config.vc
@@ -198,6 +198,7 @@ d_fd_macros='define'
 d_fd_set='define'
 d_fdclose='undef'
 d_fdim='undef'
+d_fdopendir='undef'
 d_fds_bits='define'
 d_fegetround='undef'
 d_ffs='undef'
-- 
2.43.0


From 1490431e40e22052f75a0b3449f1f53cbd27ba92 Mon Sep 17 00:00:00 2001
From: Dominic Hargreaves <dom@earth.li>
Date: Thu, 21 May 2020 22:53:37 +0100
Subject: [PATCH] Enable SSL by default in HTTP::Tiny

Gbp-Pq: Topic debian
Gbp-Pq: Name http-tiny-ssl.diff
---
 cpan/HTTP-Tiny/lib/HTTP/Tiny.pm | 20 +++++++++-----------
 1 file changed, 9 insertions(+), 11 deletions(-)

diff --git a/cpan/HTTP-Tiny/lib/HTTP/Tiny.pm b/cpan/HTTP-Tiny/lib/HTTP/Tiny.pm
index 5803e4599..88ba51461 100644
--- a/cpan/HTTP-Tiny/lib/HTTP/Tiny.pm
+++ b/cpan/HTTP-Tiny/lib/HTTP/Tiny.pm
@@ -40,7 +40,7 @@ sub _croak { require Carp; Carp::croak(@_) }
 #pod * C<timeout> — Request timeout in seconds (default is 60) If a socket open,
 #pod   read or write takes longer than the timeout, an exception is thrown.
 #pod * C<verify_SSL> — A boolean that indicates whether to validate the SSL
-#pod   certificate of an C<https> — connection (default is false)
+#pod   certificate of an C<https> — connection (default is true)
 #pod * C<SSL_options> — A hashref of C<SSL_*> — options to pass through to
 #pod   L<IO::Socket::SSL>
 #pod
@@ -112,7 +112,7 @@ sub new {
         max_redirect => 5,
         timeout      => defined $args{timeout} ? $args{timeout} : 60,
         keep_alive   => 1,
-        verify_SSL   => $args{verify_SSL} || $args{verify_ssl} || 0, # no verification by default
+        verify_SSL   => $args{verify_SSL} // $args{verify_ssl} // 1, # verification by default
         no_proxy     => $ENV{no_proxy},
     };
 
@@ -1038,7 +1038,7 @@ sub new {
         timeout          => 60,
         max_line_size    => 16384,
         max_header_lines => 64,
-        verify_SSL       => 0,
+        verify_SSL       => 1,
         SSL_options      => {},
         %args
     }, $class;
@@ -1765,7 +1765,7 @@ C<timeout> — Request timeout in seconds (default is 60) If a socket open, read
 
 =item *
 
-C<verify_SSL> — A boolean that indicates whether to validate the SSL certificate of an C<https> — connection (default is false)
+C<verify_SSL> — A boolean that indicates whether to validate the SSL certificate of an C<https> — connection (default is true)
 
 =item *
 
@@ -2035,7 +2035,7 @@ Verification of server identity
 
 =back
 
-B<By default, HTTP::Tiny does not verify server identity>.
+B<By default, HTTP::Tiny in Debian verifies server identity.
 
 Server identity verification is controversial and potentially tricky because it
 depends on a (usually paid) third-party Certificate Authority (CA) trust model
@@ -2043,16 +2043,14 @@ to validate a certificate as legitimate.  This discriminates against servers
 with self-signed certificates or certificates signed by free, community-driven
 CA's such as L<CAcert.org|http://cacert.org>.
 
-By default, HTTP::Tiny does not make any assumptions about your trust model,
-threat level or risk tolerance.  It just aims to give you an encrypted channel
-when you need one.
-
 Setting the C<verify_SSL> attribute to a true value will make HTTP::Tiny verify
 that an SSL connection has a valid SSL certificate corresponding to the host
 name of the connection and that the SSL certificate has been verified by a CA.
 Assuming you trust the CA, this will protect against a L<man-in-the-middle
-attack|http://en.wikipedia.org/wiki/Man-in-the-middle_attack>.  If you are
-concerned about security, you should enable this option.
+attack|http://en.wikipedia.org/wiki/Man-in-the-middle_attack>.
+
+If you are not concerned about security, and this default in Debian causes
+problems, you should disable this option.
 
 Certificate verification requires a file containing trusted CA certificates.
 
-- 
GitLab
