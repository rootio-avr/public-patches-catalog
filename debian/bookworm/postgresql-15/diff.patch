From 703b3fd5de5d7bfe9cb3948601bc165da024256d Mon Sep 17 00:00:00 2001
From: Andres Freund <andres@anarazel.de>
Date: Mon, 10 Feb 2025 10:03:39 -0500
Subject: [PATCH 89/97] Add pg_encoding_set_invalid()

There are cases where we cannot / do not want to error out for invalidly
encoded input. In such cases it can be useful to replace e.g. an incomplete
multi-byte characters with bytes that will trigger an error when getting
validated as part of a larger string.

Unfortunately, until now, for some encoding no such sequence existed. For
those encodings this commit removes one previously accepted input combination
- we consider that to be ok, as the chosen bytes are outside of the valid
ranges for the encodings, we just previously failed to detect that.

As we cannot add a new field to pg_wchar_table without breaking ABI, this is
implemented "in-line" in the newly added function.

Author: Noah Misch <noah@leadboat.com>
Reviewed-by: Andres Freund <andres@anarazel.de>
Backpatch-through: 13
Security: CVE-2025-1094
---
 src/common/wchar.c                       | 55 +++++++++++++++++++++++-
 src/include/mb/pg_wchar.h                |  1 +
 src/test/regress/expected/conversion.out |  7 +++
 src/test/regress/regress.c               | 50 +++++++++++++++++++++
 src/test/regress/sql/conversion.sql      |  5 +++
 5 files changed, 117 insertions(+), 1 deletion(-)

diff --git a/src/common/wchar.c b/src/common/wchar.c
index ea46192e364..4f3621fef12 100644
--- a/src/common/wchar.c
+++ b/src/common/wchar.c
@@ -16,6 +16,25 @@
 #include "utils/ascii.h"
 
 
+/*
+ * In today's multibyte encodings other than UTF8, this two-byte sequence
+ * ensures pg_encoding_mblen() == 2 && pg_encoding_verifymbstr() == 0.
+ *
+ * For historical reasons, several verifychar implementations opt to reject
+ * this pair specifically.  Byte pair range constraints, in encoding
+ * originator documentation, always excluded this pair.  No core conversion
+ * could translate it.  However, longstanding verifychar implementations
+ * accepted any non-NUL byte.  big5_to_euc_tw and big5_to_mic even translate
+ * pairs not valid per encoding originator documentation.  To avoid tightening
+ * core or non-core conversions in a security patch, we sought this one pair.
+ *
+ * PQescapeString() historically used spaces for BYTE1; many other values
+ * could suffice for BYTE1.
+ */
+#define NONUTF8_INVALID_BYTE0 (0x8d)
+#define NONUTF8_INVALID_BYTE1 (' ')
+
+
 /*
  * Operations on multi-byte encodings are driven by a table of helper
  * functions.
@@ -1526,6 +1545,11 @@ pg_big5_verifychar(const unsigned char *s, int len)
 	if (len < l)
 		return -1;
 
+	if (l == 2 &&
+		s[0] == NONUTF8_INVALID_BYTE0 &&
+		s[1] == NONUTF8_INVALID_BYTE1)
+		return -1;
+
 	while (--l > 0)
 	{
 		if (*++s == '\0')
@@ -1575,6 +1599,11 @@ pg_gbk_verifychar(const unsigned char *s, int len)
 	if (len < l)
 		return -1;
 
+	if (l == 2 &&
+		s[0] == NONUTF8_INVALID_BYTE0 &&
+		s[1] == NONUTF8_INVALID_BYTE1)
+		return -1;
+
 	while (--l > 0)
 	{
 		if (*++s == '\0')
@@ -1624,6 +1653,11 @@ pg_uhc_verifychar(const unsigned char *s, int len)
 	if (len < l)
 		return -1;
 
+	if (l == 2 &&
+		s[0] == NONUTF8_INVALID_BYTE0 &&
+		s[1] == NONUTF8_INVALID_BYTE1)
+		return -1;
+
 	while (--l > 0)
 	{
 		if (*++s == '\0')
@@ -2067,6 +2101,19 @@ pg_utf8_islegal(const unsigned char *source, int length)
 }
 
 
+/*
+ * Fills the provided buffer with two bytes such that:
+ *   pg_encoding_mblen(dst) == 2 && pg_encoding_verifymbstr(dst) == 0
+ */
+void
+pg_encoding_set_invalid(int encoding, char *dst)
+{
+	Assert(pg_encoding_max_length(encoding) > 1);
+
+	dst[0] = (encoding == PG_UTF8 ? 0xc0 : NONUTF8_INVALID_BYTE0);
+	dst[1] = NONUTF8_INVALID_BYTE1;
+}
+
 /*
  *-------------------------------------------------------------------
  * encoding info table
@@ -2189,5 +2236,11 @@ pg_encoding_max_length(int encoding)
 {
 	Assert(PG_VALID_ENCODING(encoding));
 
-	return pg_wchar_table[encoding].maxmblen;
+	/*
+	 * Check for the encoding despite the assert, due to some mingw versions
+	 * otherwise issuing bogus warnings.
+	 */
+	return PG_VALID_ENCODING(encoding) ?
+		pg_wchar_table[encoding].maxmblen :
+		pg_wchar_table[PG_SQL_ASCII].maxmblen;
 }
diff --git a/src/include/mb/pg_wchar.h b/src/include/mb/pg_wchar.h
index 4a0e6bfbccd..0e9e412a82e 100644
--- a/src/include/mb/pg_wchar.h
+++ b/src/include/mb/pg_wchar.h
@@ -573,6 +573,7 @@ extern int	pg_valid_server_encoding_id(int encoding);
  * (in addition to the ones just above).  The constant tables declared
  * earlier in this file are also available from libpgcommon.
  */
+extern void pg_encoding_set_invalid(int encoding, char *dst);
 extern int	pg_encoding_mblen(int encoding, const char *mbstr);
 extern int	pg_encoding_mblen_bounded(int encoding, const char *mbstr);
 extern int	pg_encoding_dsplen(int encoding, const char *mbstr);
diff --git a/src/test/regress/expected/conversion.out b/src/test/regress/expected/conversion.out
index 442e7aff2b2..d785f92561e 100644
--- a/src/test/regress/expected/conversion.out
+++ b/src/test/regress/expected/conversion.out
@@ -5,6 +5,13 @@
 \getenv libdir PG_LIBDIR
 \getenv dlsuffix PG_DLSUFFIX
 \set regresslib :libdir '/regress' :dlsuffix
+CREATE FUNCTION test_enc_setup() RETURNS void
+    AS :'regresslib', 'test_enc_setup'
+    LANGUAGE C STRICT;
+SELECT FROM test_enc_setup();
+--
+(1 row)
+
 CREATE FUNCTION test_enc_conversion(bytea, name, name, bool, validlen OUT int, result OUT bytea)
     AS :'regresslib', 'test_enc_conversion'
     LANGUAGE C STRICT;
diff --git a/src/test/regress/regress.c b/src/test/regress/regress.c
index 6764589418e..5c0ecbace42 100644
--- a/src/test/regress/regress.c
+++ b/src/test/regress/regress.c
@@ -1099,6 +1099,56 @@ test_opclass_options_func(PG_FUNCTION_ARGS)
 	PG_RETURN_NULL();
 }
 
+/* one-time tests for encoding infrastructure */
+PG_FUNCTION_INFO_V1(test_enc_setup);
+Datum
+test_enc_setup(PG_FUNCTION_ARGS)
+{
+	/* Test pg_encoding_set_invalid() */
+	for (int i = 0; i < _PG_LAST_ENCODING_; i++)
+	{
+		char		buf[2],
+					bigbuf[16];
+		int			len,
+					mblen,
+					valid;
+
+		if (pg_encoding_max_length(i) == 1)
+			continue;
+		pg_encoding_set_invalid(i, buf);
+		len = strnlen(buf, 2);
+		if (len != 2)
+			elog(WARNING,
+				 "official invalid string for encoding \"%s\" has length %d",
+				 pg_enc2name_tbl[i].name, len);
+		mblen = pg_encoding_mblen(i, buf);
+		if (mblen != 2)
+			elog(WARNING,
+				 "official invalid string for encoding \"%s\" has mblen %d",
+				 pg_enc2name_tbl[i].name, mblen);
+		valid = pg_encoding_verifymbstr(i, buf, len);
+		if (valid != 0)
+			elog(WARNING,
+				 "official invalid string for encoding \"%s\" has valid prefix of length %d",
+				 pg_enc2name_tbl[i].name, valid);
+		valid = pg_encoding_verifymbstr(i, buf, 1);
+		if (valid != 0)
+			elog(WARNING,
+				 "first byte of official invalid string for encoding \"%s\" has valid prefix of length %d",
+				 pg_enc2name_tbl[i].name, valid);
+		memset(bigbuf, ' ', sizeof(bigbuf));
+		bigbuf[0] = buf[0];
+		bigbuf[1] = buf[1];
+		valid = pg_encoding_verifymbstr(i, bigbuf, sizeof(bigbuf));
+		if (valid != 0)
+			elog(WARNING,
+				 "trailing data changed official invalid string for encoding \"%s\" to have valid prefix of length %d",
+				 pg_enc2name_tbl[i].name, valid);
+	}
+
+	PG_RETURN_VOID();
+}
+
 /*
  * Call an encoding conversion or verification function.
  *
diff --git a/src/test/regress/sql/conversion.sql b/src/test/regress/sql/conversion.sql
index 9a65fca91fb..b567a1a5721 100644
--- a/src/test/regress/sql/conversion.sql
+++ b/src/test/regress/sql/conversion.sql
@@ -8,6 +8,11 @@
 
 \set regresslib :libdir '/regress' :dlsuffix
 
+CREATE FUNCTION test_enc_setup() RETURNS void
+    AS :'regresslib', 'test_enc_setup'
+    LANGUAGE C STRICT;
+SELECT FROM test_enc_setup();
+
 CREATE FUNCTION test_enc_conversion(bytea, name, name, bool, validlen OUT int, result OUT bytea)
     AS :'regresslib', 'test_enc_conversion'
     LANGUAGE C STRICT;
-- 
2.43.0


From b1756da7541323eae07fe23eaad17ce12f20a56b Mon Sep 17 00:00:00 2001
From: Andres Freund <andres@anarazel.de>
Date: Mon, 10 Feb 2025 10:03:39 -0500
Subject: [PATCH 90/97] Specify the encoding of input to fmtId()

This commit adds fmtIdEnc() and fmtQualifiedIdEnc(), which allow to specify
the encoding as an explicit argument.  Additionally setFmtEncoding() is
provided, which defines the encoding when no explicit encoding is provided, to
avoid breaking all code using fmtId().

All users of fmtId()/fmtQualifiedId() are either converted to the explicit
version or a call to setFmtEncoding() has been added.

This commit does not yet utilize the now well-defined encoding, that will
happen in a subsequent commit.

Reviewed-by: Noah Misch <noah@leadboat.com>
Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
Backpatch-through: 13
Security: CVE-2025-1094
---
 src/bin/pg_dump/pg_backup_archiver.c |  1 +
 src/bin/pg_dump/pg_dump.c            |  1 +
 src/bin/pg_dump/pg_dumpall.c         |  1 +
 src/bin/psql/command.c               |  3 +
 src/bin/scripts/common.c             |  5 +-
 src/bin/scripts/createdb.c           |  2 +
 src/bin/scripts/createuser.c         |  2 +
 src/bin/scripts/dropdb.c             | 13 ++---
 src/bin/scripts/dropuser.c           |  3 +-
 src/bin/scripts/reindexdb.c          | 11 ++--
 src/bin/scripts/vacuumdb.c           |  5 +-
 src/fe_utils/string_utils.c          | 84 ++++++++++++++++++++++++++--
 src/include/fe_utils/string_utils.h  |  3 +
 13 files changed, 112 insertions(+), 22 deletions(-)

diff --git a/src/bin/pg_dump/pg_backup_archiver.c b/src/bin/pg_dump/pg_backup_archiver.c
index ea979b50b00..55b24f1837f 100644
--- a/src/bin/pg_dump/pg_backup_archiver.c
+++ b/src/bin/pg_dump/pg_backup_archiver.c
@@ -2733,6 +2733,7 @@ processEncodingEntry(ArchiveHandle *AH, TocEntry *te)
 			pg_fatal("unrecognized encoding \"%s\"",
 					 ptr1);
 		AH->public.encoding = encoding;
+		setFmtEncoding(encoding);
 	}
 	else
 		pg_fatal("invalid ENCODING item: %s",
diff --git a/src/bin/pg_dump/pg_dump.c b/src/bin/pg_dump/pg_dump.c
index 2f3bd130390..52c9ff847fd 100644
--- a/src/bin/pg_dump/pg_dump.c
+++ b/src/bin/pg_dump/pg_dump.c
@@ -1095,6 +1095,7 @@ setup_connection(Archive *AH, const char *dumpencoding,
 	 * we know how to escape strings.
 	 */
 	AH->encoding = PQclientEncoding(conn);
+	setFmtEncoding(AH->encoding);
 
 	std_strings = PQparameterStatus(conn, "standard_conforming_strings");
 	AH->std_strings = (std_strings && strcmp(std_strings, "on") == 0);
diff --git a/src/bin/pg_dump/pg_dumpall.c b/src/bin/pg_dump/pg_dumpall.c
index 950bc41380d..623cc6c1a90 100644
--- a/src/bin/pg_dump/pg_dumpall.c
+++ b/src/bin/pg_dump/pg_dumpall.c
@@ -494,6 +494,7 @@ main(int argc, char *argv[])
 	 * we know how to escape strings.
 	 */
 	encoding = PQclientEncoding(conn);
+	setFmtEncoding(encoding);
 	std_strings = PQparameterStatus(conn, "standard_conforming_strings");
 	if (!std_strings)
 		std_strings = "off";
diff --git a/src/bin/psql/command.c b/src/bin/psql/command.c
index b9fd475eb91..57cef4fa670 100644
--- a/src/bin/psql/command.c
+++ b/src/bin/psql/command.c
@@ -1285,6 +1285,7 @@ exec_command_encoding(PsqlScanState scan_state, bool active_branch)
 				/* save encoding info into psql internal data */
 				pset.encoding = PQclientEncoding(pset.db);
 				pset.popt.topt.encoding = pset.encoding;
+				setFmtEncoding(pset.encoding);
 				SetVariable(pset.vars, "ENCODING",
 							pg_encoding_to_char(pset.encoding));
 			}
@@ -3740,6 +3741,8 @@ SyncVariables(void)
 	pset.popt.topt.encoding = pset.encoding;
 	pset.sversion = PQserverVersion(pset.db);
 
+	setFmtEncoding(pset.encoding);
+
 	SetVariable(pset.vars, "DBNAME", PQdb(pset.db));
 	SetVariable(pset.vars, "USER", PQuser(pset.db));
 	SetVariable(pset.vars, "HOST", PQhost(pset.db));
diff --git a/src/bin/scripts/common.c b/src/bin/scripts/common.c
index 9e38b60a655..e92b586c96b 100644
--- a/src/bin/scripts/common.c
+++ b/src/bin/scripts/common.c
@@ -112,8 +112,9 @@ appendQualifiedRelation(PQExpBuffer buf, const char *spec,
 		exit(1);
 	}
 	appendPQExpBufferStr(buf,
-						 fmtQualifiedId(PQgetvalue(res, 0, 1),
-										PQgetvalue(res, 0, 0)));
+						 fmtQualifiedIdEnc(PQgetvalue(res, 0, 1),
+										   PQgetvalue(res, 0, 0),
+										   PQclientEncoding(conn)));
 	appendPQExpBufferStr(buf, columns);
 	PQclear(res);
 	termPQExpBuffer(&sql);
diff --git a/src/bin/scripts/createdb.c b/src/bin/scripts/createdb.c
index cbeef4f54f0..e7859b80e13 100644
--- a/src/bin/scripts/createdb.c
+++ b/src/bin/scripts/createdb.c
@@ -196,6 +196,8 @@ main(int argc, char *argv[])
 
 	conn = connectMaintenanceDatabase(&cparams, progname, echo);
 
+	setFmtEncoding(PQclientEncoding(conn));
+
 	initPQExpBuffer(&sql);
 
 	appendPQExpBuffer(&sql, "CREATE DATABASE %s",
diff --git a/src/bin/scripts/createuser.c b/src/bin/scripts/createuser.c
index bfba0d09d11..28436a2a273 100644
--- a/src/bin/scripts/createuser.c
+++ b/src/bin/scripts/createuser.c
@@ -261,6 +261,8 @@ main(int argc, char *argv[])
 
 	conn = connectMaintenanceDatabase(&cparams, progname, echo);
 
+	setFmtEncoding(PQclientEncoding(conn));
+
 	initPQExpBuffer(&sql);
 
 	printfPQExpBuffer(&sql, "CREATE ROLE %s", fmtId(newuser));
diff --git a/src/bin/scripts/dropdb.c b/src/bin/scripts/dropdb.c
index afc00dac784..5f183579f10 100644
--- a/src/bin/scripts/dropdb.c
+++ b/src/bin/scripts/dropdb.c
@@ -129,13 +129,6 @@ main(int argc, char *argv[])
 			exit(0);
 	}
 
-	initPQExpBuffer(&sql);
-
-	appendPQExpBuffer(&sql, "DROP DATABASE %s%s%s;",
-					  (if_exists ? "IF EXISTS " : ""),
-					  fmtId(dbname),
-					  force ? " WITH (FORCE)" : "");
-
 	/* Avoid trying to drop postgres db while we are connected to it. */
 	if (maintenance_db == NULL && strcmp(dbname, "postgres") == 0)
 		maintenance_db = "template1";
@@ -149,6 +142,12 @@ main(int argc, char *argv[])
 
 	conn = connectMaintenanceDatabase(&cparams, progname, echo);
 
+	initPQExpBuffer(&sql);
+	appendPQExpBuffer(&sql, "DROP DATABASE %s%s%s;",
+					  (if_exists ? "IF EXISTS " : ""),
+					  fmtIdEnc(dbname, PQclientEncoding(conn)),
+					  force ? " WITH (FORCE)" : "");
+
 	if (echo)
 		printf("%s\n", sql.data);
 	result = PQexec(conn, sql.data);
diff --git a/src/bin/scripts/dropuser.c b/src/bin/scripts/dropuser.c
index 82c1f35ab23..aaee4437d16 100644
--- a/src/bin/scripts/dropuser.c
+++ b/src/bin/scripts/dropuser.c
@@ -143,7 +143,8 @@ main(int argc, char *argv[])
 
 	initPQExpBuffer(&sql);
 	appendPQExpBuffer(&sql, "DROP ROLE %s%s;",
-					  (if_exists ? "IF EXISTS " : ""), fmtId(dropuser));
+					  (if_exists ? "IF EXISTS " : ""),
+					  fmtIdEnc(dropuser, PQclientEncoding(conn)));
 
 	if (echo)
 		printf("%s\n", sql.data);
diff --git a/src/bin/scripts/reindexdb.c b/src/bin/scripts/reindexdb.c
index eb1e6fe825a..8db37a72306 100644
--- a/src/bin/scripts/reindexdb.c
+++ b/src/bin/scripts/reindexdb.c
@@ -501,7 +501,8 @@ run_reindex_command(PGconn *conn, ReindexType type, const char *name,
 
 	if (tablespace)
 	{
-		appendPQExpBuffer(&sql, "%sTABLESPACE %s", sep, fmtId(tablespace));
+		appendPQExpBuffer(&sql, "%sTABLESPACE %s", sep,
+						  fmtIdEnc(tablespace, PQclientEncoding(conn)));
 		sep = comma;
 	}
 
@@ -541,7 +542,8 @@ run_reindex_command(PGconn *conn, ReindexType type, const char *name,
 	{
 		case REINDEX_DATABASE:
 		case REINDEX_SYSTEM:
-			appendPQExpBufferStr(&sql, fmtId(name));
+			appendPQExpBufferStr(&sql,
+								 fmtIdEnc(name, PQclientEncoding(conn)));
 			break;
 		case REINDEX_INDEX:
 		case REINDEX_TABLE:
@@ -711,8 +713,9 @@ get_parallel_object_list(PGconn *conn, ReindexType type,
 	for (i = 0; i < ntups; i++)
 	{
 		appendPQExpBufferStr(&buf,
-							 fmtQualifiedId(PQgetvalue(res, i, 1),
-											PQgetvalue(res, i, 0)));
+							 fmtQualifiedIdEnc(PQgetvalue(res, i, 1),
+											   PQgetvalue(res, i, 0),
+											   PQclientEncoding(conn)));
 
 		simple_string_list_append(tables, buf.data);
 		resetPQExpBuffer(&buf);
diff --git a/src/bin/scripts/vacuumdb.c b/src/bin/scripts/vacuumdb.c
index cc43141f0a0..425b505afe2 100644
--- a/src/bin/scripts/vacuumdb.c
+++ b/src/bin/scripts/vacuumdb.c
@@ -646,8 +646,9 @@ vacuum_one_database(ConnParams *cparams,
 	for (i = 0; i < ntups; i++)
 	{
 		appendPQExpBufferStr(&buf,
-							 fmtQualifiedId(PQgetvalue(res, i, 1),
-											PQgetvalue(res, i, 0)));
+							 fmtQualifiedIdEnc(PQgetvalue(res, i, 1),
+											   PQgetvalue(res, i, 0),
+											   PQclientEncoding(conn)));
 
 		if (tables_listed && !PQgetisnull(res, i, 2))
 			appendPQExpBufferStr(&buf, PQgetvalue(res, i, 2));
diff --git a/src/fe_utils/string_utils.c b/src/fe_utils/string_utils.c
index f311bdd3ad5..d3640f8ec1d 100644
--- a/src/fe_utils/string_utils.c
+++ b/src/fe_utils/string_utils.c
@@ -19,6 +19,7 @@
 
 #include "common/keywords.h"
 #include "fe_utils/string_utils.h"
+#include "mb/pg_wchar.h"
 
 static PQExpBuffer defaultGetLocalPQExpBuffer(void);
 
@@ -26,6 +27,8 @@ static PQExpBuffer defaultGetLocalPQExpBuffer(void);
 int			quote_all_identifiers = 0;
 PQExpBuffer (*getLocalPQExpBuffer) (void) = defaultGetLocalPQExpBuffer;
 
+static int	fmtIdEncoding = -1;
+
 
 /*
  * Returns a temporary PQExpBuffer, valid until the next call to the function.
@@ -54,14 +57,48 @@ defaultGetLocalPQExpBuffer(void)
 	return id_return;
 }
 
+/*
+ * Set the encoding that fmtId() and fmtQualifiedId() use.
+ *
+ * This is not safe against multiple connections having different encodings,
+ * but there is no real other way to address the need to know the encoding for
+ * fmtId()/fmtQualifiedId() input for safe escaping. Eventually we should get
+ * rid of fmtId().
+ */
+void
+setFmtEncoding(int encoding)
+{
+	fmtIdEncoding = encoding;
+}
+
+/*
+ * Return the currently configured encoding for fmtId() and fmtQualifiedId().
+ */
+static int
+getFmtEncoding(void)
+{
+	if (fmtIdEncoding != -1)
+		return fmtIdEncoding;
+
+	/*
+	 * In assertion builds it seems best to fail hard if the encoding was not
+	 * set, to make it easier to find places with missing calls. But in
+	 * production builds that seems like a bad idea, thus we instead just
+	 * default to UTF-8.
+	 */
+	Assert(fmtIdEncoding != -1);
+
+	return PG_UTF8;
+}
+
 /*
  *	Quotes input string if it's not a legitimate SQL identifier as-is.
  *
- *	Note that the returned string must be used before calling fmtId again,
+ *	Note that the returned string must be used before calling fmtIdEnc again,
  *	since we re-use the same return buffer each time.
  */
 const char *
-fmtId(const char *rawid)
+fmtIdEnc(const char *rawid, int encoding)
 {
 	PQExpBuffer id_return = getLocalPQExpBuffer();
 
@@ -134,7 +171,24 @@ fmtId(const char *rawid)
 }
 
 /*
- * fmtQualifiedId - construct a schema-qualified name, with quoting as needed.
+ *	Quotes input string if it's not a legitimate SQL identifier as-is.
+ *
+ *	Note that the returned string must be used before calling fmtId again,
+ *	since we re-use the same return buffer each time.
+ *
+ *  NB: This assumes setFmtEncoding() previously has been called to configure
+ *  the encoding of rawid. It is preferable to use fmtIdEnc() with an
+ *  explicit encoding.
+ */
+const char *
+fmtId(const char *rawid)
+{
+	return fmtIdEnc(rawid, getFmtEncoding());
+}
+
+/*
+ * fmtQualifiedIdEnc - construct a schema-qualified name, with quoting as
+ * needed.
  *
  * Like fmtId, use the result before calling again.
  *
@@ -142,7 +196,7 @@ fmtId(const char *rawid)
  * use that buffer until we're finished with calling fmtId().
  */
 const char *
-fmtQualifiedId(const char *schema, const char *id)
+fmtQualifiedIdEnc(const char *schema, const char *id, int encoding)
 {
 	PQExpBuffer id_return;
 	PQExpBuffer lcl_pqexp = createPQExpBuffer();
@@ -150,9 +204,9 @@ fmtQualifiedId(const char *schema, const char *id)
 	/* Some callers might fail to provide a schema name */
 	if (schema && *schema)
 	{
-		appendPQExpBuffer(lcl_pqexp, "%s.", fmtId(schema));
+		appendPQExpBuffer(lcl_pqexp, "%s.", fmtIdEnc(schema, encoding));
 	}
-	appendPQExpBufferStr(lcl_pqexp, fmtId(id));
+	appendPQExpBufferStr(lcl_pqexp, fmtIdEnc(id, encoding));
 
 	id_return = getLocalPQExpBuffer();
 
@@ -162,6 +216,24 @@ fmtQualifiedId(const char *schema, const char *id)
 	return id_return->data;
 }
 
+/*
+ * fmtQualifiedId - construct a schema-qualified name, with quoting as needed.
+ *
+ * Like fmtId, use the result before calling again.
+ *
+ * Since we call fmtId and it also uses getLocalPQExpBuffer() we cannot
+ * use that buffer until we're finished with calling fmtId().
+ *
+ * NB: This assumes setFmtEncoding() previously has been called to configure
+ * the encoding of schema/id. It is preferable to use fmtQualifiedIdEnc()
+ * with an explicit encoding.
+ */
+const char *
+fmtQualifiedId(const char *schema, const char *id)
+{
+	return fmtQualifiedIdEnc(schema, id, getFmtEncoding());
+}
+
 
 /*
  * Format a Postgres version number (in the PG_VERSION_NUM integer format
diff --git a/src/include/fe_utils/string_utils.h b/src/include/fe_utils/string_utils.h
index fa4deb24978..92b2b2d3083 100644
--- a/src/include/fe_utils/string_utils.h
+++ b/src/include/fe_utils/string_utils.h
@@ -25,7 +25,10 @@ extern PQExpBuffer (*getLocalPQExpBuffer) (void);
 
 /* Functions */
 extern const char *fmtId(const char *identifier);
+extern const char *fmtIdEnc(const char *identifier, int encoding);
 extern const char *fmtQualifiedId(const char *schema, const char *id);
+extern const char *fmtQualifiedIdEnc(const char *schema, const char *id, int encoding);
+extern void setFmtEncoding(int encoding);
 
 extern char *formatPGVersionNumber(int version_number, bool include_minor,
 								   char *buf, size_t buflen);
-- 
2.43.0


From 370c94d4cce179736f9a255779eb8e653e1edfb2 Mon Sep 17 00:00:00 2001
From: Andres Freund <andres@anarazel.de>
Date: Mon, 10 Feb 2025 10:03:39 -0500
Subject: [PATCH 91/97] Fix handling of invalidly encoded data in escaping
 functions

Previously invalidly encoded input to various escaping functions could lead to
the escaped string getting incorrectly parsed by psql.  To be safe, escaping
functions need to ensure that neither invalid nor incomplete multi-byte
characters can be used to "escape" from being quoted.

Functions which can report errors now return an error in more cases than
before. Functions that cannot report errors now replace invalid input bytes
with a byte sequence that cannot be used to escape the quotes and that is
guaranteed to error out when a query is sent to the server.

The following functions are fixed by this commit:
- PQescapeLiteral()
- PQescapeIdentifier()
- PQescapeString()
- PQescapeStringConn()
- fmtId()
- appendStringLiteral()

Reported-by: Stephen Fewer <stephen_fewer@rapid7.com>
Reviewed-by: Noah Misch <noah@leadboat.com>
Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
Backpatch-through: 13
Security: CVE-2025-1094
---
 src/fe_utils/string_utils.c    | 170 ++++++++++++++++++++++++++-------
 src/interfaces/libpq/fe-exec.c | 135 +++++++++++++++++++-------
 2 files changed, 237 insertions(+), 68 deletions(-)

diff --git a/src/fe_utils/string_utils.c b/src/fe_utils/string_utils.c
index d3640f8ec1d..99128d74160 100644
--- a/src/fe_utils/string_utils.c
+++ b/src/fe_utils/string_utils.c
@@ -104,6 +104,7 @@ fmtIdEnc(const char *rawid, int encoding)
 
 	const char *cp;
 	bool		need_quotes = false;
+	size_t		remaining = strlen(rawid);
 
 	/*
 	 * These checks need to match the identifier production in scan.l. Don't
@@ -117,7 +118,8 @@ fmtIdEnc(const char *rawid, int encoding)
 	else
 	{
 		/* otherwise check the entire string */
-		for (cp = rawid; *cp; cp++)
+		cp = rawid;
+		for (size_t i = 0; i < remaining; i++, cp++)
 		{
 			if (!((*cp >= 'a' && *cp <= 'z')
 				  || (*cp >= '0' && *cp <= '9')
@@ -153,17 +155,90 @@ fmtIdEnc(const char *rawid, int encoding)
 	else
 	{
 		appendPQExpBufferChar(id_return, '"');
-		for (cp = rawid; *cp; cp++)
+
+		cp = &rawid[0];
+		while (remaining > 0)
 		{
-			/*
-			 * Did we find a double-quote in the string? Then make this a
-			 * double double-quote per SQL99. Before, we put in a
-			 * backslash/double-quote pair. - thomas 2000-08-05
-			 */
-			if (*cp == '"')
-				appendPQExpBufferChar(id_return, '"');
-			appendPQExpBufferChar(id_return, *cp);
+			int			charlen;
+
+			/* Fast path for plain ASCII */
+			if (!IS_HIGHBIT_SET(*cp))
+			{
+				/*
+				 * Did we find a double-quote in the string? Then make this a
+				 * double double-quote per SQL99. Before, we put in a
+				 * backslash/double-quote pair. - thomas 2000-08-05
+				 */
+				if (*cp == '"')
+					appendPQExpBufferChar(id_return, '"');
+				appendPQExpBufferChar(id_return, *cp);
+				remaining--;
+				cp++;
+				continue;
+			}
+
+			/* Slow path for possible multibyte characters */
+			charlen = pg_encoding_mblen(encoding, cp);
+
+			if (remaining < charlen)
+			{
+				/*
+				 * If the character is longer than the available input,
+				 * replace the string with an invalid sequence. The invalid
+				 * sequence ensures that the escaped string will trigger an
+				 * error on the server-side, even if we can't directly report
+				 * an error here.
+				 */
+				enlargePQExpBuffer(id_return, 2);
+				pg_encoding_set_invalid(encoding,
+										id_return->data + id_return->len);
+				id_return->len += 2;
+				id_return->data[id_return->len] = '\0';
+
+				/* there's no more input data, so we can stop */
+				break;
+			}
+			else if (pg_encoding_verifymbchar(encoding, cp, charlen) == -1)
+			{
+				/*
+				 * Multibyte character is invalid.  It's important to verify
+				 * that as invalid multi-byte characters could e.g. be used to
+				 * "skip" over quote characters, e.g. when parsing
+				 * character-by-character.
+				 *
+				 * Replace the bytes corresponding to the invalid character
+				 * with an invalid sequence, for the same reason as above.
+				 *
+				 * It would be a bit faster to verify the whole string the
+				 * first time we encounter a set highbit, but this way we can
+				 * replace just the invalid characters, which probably makes
+				 * it easier for users to find the invalidly encoded portion
+				 * of a larger string.
+				 */
+				enlargePQExpBuffer(id_return, 2);
+				pg_encoding_set_invalid(encoding,
+										id_return->data + id_return->len);
+				id_return->len += 2;
+				id_return->data[id_return->len] = '\0';
+
+				/*
+				 * Copy the rest of the string after the invalid multi-byte
+				 * character.
+				 */
+				remaining -= charlen;
+				cp += charlen;
+			}
+			else
+			{
+				for (int i = 0; i < charlen; i++)
+				{
+					appendPQExpBufferChar(id_return, *cp);
+					remaining--;
+					cp++;
+				}
+			}
 		}
+
 		appendPQExpBufferChar(id_return, '"');
 	}
 
@@ -290,6 +365,7 @@ appendStringLiteral(PQExpBuffer buf, const char *str,
 	size_t		length = strlen(str);
 	const char *source = str;
 	char	   *target;
+	size_t		remaining = length;
 
 	if (!enlargePQExpBuffer(buf, 2 * length + 2))
 		return;
@@ -297,10 +373,10 @@ appendStringLiteral(PQExpBuffer buf, const char *str,
 	target = buf->data + buf->len;
 	*target++ = '\'';
 
-	while (*source != '\0')
+	while (remaining > 0)
 	{
 		char		c = *source;
-		int			len;
+		int			charlen;
 		int			i;
 
 		/* Fast path for plain ASCII */
@@ -312,39 +388,65 @@ appendStringLiteral(PQExpBuffer buf, const char *str,
 			/* Copy the character */
 			*target++ = c;
 			source++;
+			remaining--;
 			continue;
 		}
 
 		/* Slow path for possible multibyte characters */
-		len = PQmblen(source, encoding);
+		charlen = PQmblen(source, encoding);
 
-		/* Copy the character */
-		for (i = 0; i < len; i++)
+		if (remaining < charlen)
 		{
-			if (*source == '\0')
-				break;
-			*target++ = *source++;
-		}
+			/*
+			 * If the character is longer than the available input, replace
+			 * the string with an invalid sequence. The invalid sequence
+			 * ensures that the escaped string will trigger an error on the
+			 * server-side, even if we can't directly report an error here.
+			 *
+			 * We know there's enough space for the invalid sequence because
+			 * the "target" buffer is 2 * length + 2 long, and at worst we're
+			 * replacing a single input byte with two invalid bytes.
+			 */
+			pg_encoding_set_invalid(encoding, target);
+			target += 2;
 
-		/*
-		 * If we hit premature end of string (ie, incomplete multibyte
-		 * character), try to pad out to the correct length with spaces. We
-		 * may not be able to pad completely, but we will always be able to
-		 * insert at least one pad space (since we'd not have quoted a
-		 * multibyte character).  This should be enough to make a string that
-		 * the server will error out on.
-		 */
-		if (i < len)
+			/* there's no more valid input data, so we can stop */
+			break;
+		}
+		else if (pg_encoding_verifymbchar(encoding, source, charlen) == -1)
 		{
-			char	   *stop = buf->data + buf->maxlen - 2;
+			/*
+			 * Multibyte character is invalid.  It's important to verify that
+			 * as invalid multi-byte characters could e.g. be used to "skip"
+			 * over quote characters, e.g. when parsing
+			 * character-by-character.
+			 *
+			 * Replace the bytes corresponding to the invalid character with
+			 * an invalid sequence, for the same reason as above.
+			 *
+			 * It would be a bit faster to verify the whole string the first
+			 * time we encounter a set highbit, but this way we can replace
+			 * just the invalid characters, which probably makes it easier for
+			 * users to find the invalidly encoded portion of a larger string.
+			 */
+			pg_encoding_set_invalid(encoding, target);
+			target += 2;
+			remaining -= charlen;
 
-			for (; i < len; i++)
+			/*
+			 * Copy the rest of the string after the invalid multi-byte
+			 * character.
+			 */
+			source += charlen;
+		}
+		else
+		{
+			/* Copy the character */
+			for (i = 0; i < charlen; i++)
 			{
-				if (target >= stop)
-					break;
-				*target++ = ' ';
+				*target++ = *source++;
+				remaining--;
 			}
-			break;
 		}
 	}
 
diff --git a/src/interfaces/libpq/fe-exec.c b/src/interfaces/libpq/fe-exec.c
index c9450ecff18..f1143dff815 100644
--- a/src/interfaces/libpq/fe-exec.c
+++ b/src/interfaces/libpq/fe-exec.c
@@ -3977,15 +3977,15 @@ PQescapeStringInternal(PGconn *conn,
 {
 	const char *source = from;
 	char	   *target = to;
-	size_t		remaining = length;
+	size_t		remaining = strnlen(from, length);
 
 	if (error)
 		*error = 0;
 
-	while (remaining > 0 && *source != '\0')
+	while (remaining > 0)
 	{
 		char		c = *source;
-		int			len;
+		int			charlen;
 		int			i;
 
 		/* Fast path for plain ASCII */
@@ -4002,39 +4002,78 @@ PQescapeStringInternal(PGconn *conn,
 		}
 
 		/* Slow path for possible multibyte characters */
-		len = pg_encoding_mblen(encoding, source);
+		charlen = pg_encoding_mblen(encoding, source);
 
-		/* Copy the character */
-		for (i = 0; i < len; i++)
+		if (remaining < charlen)
 		{
-			if (remaining == 0 || *source == '\0')
-				break;
-			*target++ = *source++;
-			remaining--;
-		}
+			/*
+			 * If the character is longer than the available input, report an
+			 * error if possible, and replace the string with an invalid
+			 * sequence. The invalid sequence ensures that the escaped string
+			 * will trigger an error on the server-side, even if we can't
+			 * directly report an error here.
+			 *
+			 * This isn't *that* crucial when we can report an error to the
+			 * caller, but if we can't, the caller will use this string
+			 * unmodified and it needs to be safe for parsing.
+			 *
+			 * We know there's enough space for the invalid sequence because
+			 * the "to" buffer needs to be at least 2 * length + 1 long, and
+			 * at worst we're replacing a single input byte with two invalid
+			 * bytes.
+			 */
+			if (error)
+				*error = 1;
+			if (conn)
+				appendPQExpBufferStr(&conn->errorMessage,
+									 libpq_gettext("incomplete multibyte character\n"));
 
-		/*
-		 * If we hit premature end of string (ie, incomplete multibyte
-		 * character), try to pad out to the correct length with spaces. We
-		 * may not be able to pad completely, but we will always be able to
-		 * insert at least one pad space (since we'd not have quoted a
-		 * multibyte character).  This should be enough to make a string that
-		 * the server will error out on.
-		 */
-		if (i < len)
+			pg_encoding_set_invalid(encoding, target);
+			target += 2;
+
+			/* there's no more input data, so we can stop */
+			break;
+		}
+		else if (pg_encoding_verifymbchar(encoding, source, charlen) == -1)
 		{
+			/*
+			 * Multibyte character is invalid.  It's important to verify that
+			 * as invalid multi-byte characters could e.g. be used to "skip"
+			 * over quote characters, e.g. when parsing
+			 * character-by-character.
+			 *
+			 * Replace the bytes corresponding to the invalid character with
+			 * an invalid sequence, for the same reason as above.
+			 *
+			 * It would be a bit faster to verify the whole string the first
+			 * time we encounter a set highbit, but this way we can replace
+			 * just the invalid characters, which probably makes it easier for
+			 * users to find the invalidly encoded portion of a larger string.
+			 */
 			if (error)
 				*error = 1;
 			if (conn)
 				appendPQExpBufferStr(&conn->errorMessage,
-									 libpq_gettext("incomplete multibyte character\n"));
-			for (; i < len; i++)
+									 libpq_gettext("invalid multibyte character\n"));
+
+			pg_encoding_set_invalid(encoding, target);
+			target += 2;
+			remaining -= charlen;
+
+			/*
+			 * Copy the rest of the string after the invalid multi-byte
+			 * character.
+			 */
+			source += charlen;
+		}
+		else
+		{
+			/* Copy the character */
+			for (i = 0; i < charlen; i++)
 			{
-				if (((size_t) (target - to)) / 2 >= length)
-					break;
-				*target++ = ' ';
+				*target++ = *source++;
+				remaining--;
 			}
-			break;
 		}
 	}
 
@@ -4089,9 +4128,10 @@ PQescapeInternal(PGconn *conn, const char *str, size_t len, bool as_ident)
 	char	   *rp;
 	int			num_quotes = 0; /* single or double, depending on as_ident */
 	int			num_backslashes = 0;
-	int			input_len;
-	int			result_size;
+	size_t		input_len = strlen(str);
+	size_t		result_size;
 	char		quote_char = as_ident ? '"' : '\'';
+	bool		validated_mb = false;
 
 	/* We must have a connection, else fail immediately. */
 	if (!conn)
@@ -4100,8 +4140,12 @@ PQescapeInternal(PGconn *conn, const char *str, size_t len, bool as_ident)
 	if (conn->cmd_queue_head == NULL)
 		pqClearConnErrorState(conn);
 
-	/* Scan the string for characters that must be escaped. */
-	for (s = str; (s - str) < len && *s != '\0'; ++s)
+	/*
+	 * Scan the string for characters that must be escaped and for invalidly
+	 * encoded data.
+	 */
+	s = str;
+	for (size_t remaining = input_len; remaining > 0; remaining--, s++)
 	{
 		if (*s == quote_char)
 			++num_quotes;
@@ -4114,21 +4158,42 @@ PQescapeInternal(PGconn *conn, const char *str, size_t len, bool as_ident)
 			/* Slow path for possible multibyte characters */
 			charlen = pg_encoding_mblen(conn->client_encoding, s);
 
-			/* Multibyte character overruns allowable length. */
-			if ((s - str) + charlen > len || memchr(s, 0, charlen) != NULL)
+			if (charlen > remaining)
 			{
 				appendPQExpBufferStr(&conn->errorMessage,
 									 libpq_gettext("incomplete multibyte character\n"));
 				return NULL;
 			}
 
+			/*
+			 * If we haven't already, check that multibyte characters are
+			 * valid. It's important to verify that as invalid multi-byte
+			 * characters could e.g. be used to "skip" over quote characters,
+			 * e.g. when parsing character-by-character.
+			 *
+			 * We check validity once, for the whole remainder of the string,
+			 * when we first encounter any multi-byte character. Some
+			 * encodings have optimized implementations for longer strings.
+			 */
+			if (!validated_mb)
+			{
+				if (pg_encoding_verifymbstr(conn->client_encoding, s, remaining)
+					!= strlen(s))
+				{
+					appendPQExpBufferStr(&conn->errorMessage,
+										 libpq_gettext("invalid multibyte character\n"));
+					return NULL;
+				}
+				validated_mb = true;
+			}
+
 			/* Adjust s, bearing in mind that for loop will increment it. */
 			s += charlen - 1;
+			remaining -= charlen - 1;
 		}
 	}
 
 	/* Allocate output buffer. */
-	input_len = s - str;
 	result_size = input_len + num_quotes + 3;	/* two quotes, plus a NUL */
 	if (!as_ident && num_backslashes > 0)
 		result_size += num_backslashes + 2;
@@ -4174,7 +4239,8 @@ PQescapeInternal(PGconn *conn, const char *str, size_t len, bool as_ident)
 	}
 	else
 	{
-		for (s = str; s - str < input_len; ++s)
+		s = str;
+		for (size_t remaining = input_len; remaining > 0; remaining--, s++)
 		{
 			if (*s == quote_char || (!as_ident && *s == '\\'))
 			{
@@ -4192,6 +4258,7 @@ PQescapeInternal(PGconn *conn, const char *str, size_t len, bool as_ident)
 					*rp++ = *s;
 					if (--i == 0)
 						break;
+					remaining--;
 					++s;		/* for loop will provide the final increment */
 				}
 			}
-- 
2.43.0


From de4b92f3332b7ea3373ae7bad0d790473b3665e6 Mon Sep 17 00:00:00 2001
From: Andres Freund <andres@anarazel.de>
Date: Mon, 10 Feb 2025 10:03:39 -0500
Subject: [PATCH 92/97] Add test of various escape functions

As highlighted by the prior commit, writing correct escape functions is less
trivial than one might hope.

This test module tries to verify that different escaping functions behave
reasonably. It e.g. tests:

- Invalidly encoded input to an escape function leads to invalidly encoded
  output

- Trailing incomplete multi-byte characters are handled sensibly

- Escaped strings are parsed as single statement by psql's parser (which
  derives from the backend parser)

There are further tests that would be good to add. But even in the current
state it was rather useful for writing the fix in the prior commit.

Reviewed-by: Noah Misch <noah@leadboat.com>
Backpatch-through: 13
Security: CVE-2025-1094
---
 src/test/modules/Makefile                     |   1 +
 src/test/modules/test_escape/.gitignore       |   2 +
 src/test/modules/test_escape/Makefile         |  27 +
 .../modules/test_escape/t/001_test_escape.pl  |  53 ++
 src/test/modules/test_escape/test_escape.c    | 803 ++++++++++++++++++
 src/tools/msvc/Mkvcbuild.pm                   |   2 +-
 src/tools/pgindent/typedefs.list              |   3 +
 7 files changed, 890 insertions(+), 1 deletion(-)
 create mode 100644 src/test/modules/test_escape/.gitignore
 create mode 100644 src/test/modules/test_escape/Makefile
 create mode 100644 src/test/modules/test_escape/t/001_test_escape.pl
 create mode 100644 src/test/modules/test_escape/test_escape.c

diff --git a/src/test/modules/Makefile b/src/test/modules/Makefile
index 9090226daa0..317fedddb0c 100644
--- a/src/test/modules/Makefile
+++ b/src/test/modules/Makefile
@@ -16,6 +16,7 @@ SUBDIRS = \
 		  spgist_name_ops \
 		  test_bloomfilter \
 		  test_ddl_deparse \
+		  test_escape \
 		  test_extensions \
 		  test_ginpostinglist \
 		  test_integerset \
diff --git a/src/test/modules/test_escape/.gitignore b/src/test/modules/test_escape/.gitignore
new file mode 100644
index 00000000000..e498d6b7efa
--- /dev/null
+++ b/src/test/modules/test_escape/.gitignore
@@ -0,0 +1,2 @@
+/tmp_check/
+/test_escape
diff --git a/src/test/modules/test_escape/Makefile b/src/test/modules/test_escape/Makefile
new file mode 100644
index 00000000000..786db4cbae4
--- /dev/null
+++ b/src/test/modules/test_escape/Makefile
@@ -0,0 +1,27 @@
+# src/test/modules/test_escape/Makefile
+
+PGFILEDESC = "test escape program"
+PGAPPICON = win32
+
+PROGRAM = test_escape
+OBJS = $(WIN32RES) test_escape.o
+
+PG_CPPFLAGS = -I$(libpq_srcdir)
+PG_LIBS_INTERNAL += -L$(top_builddir)/src/fe_utils -lpgfeutils $(libpq_pgport)
+
+NO_INSTALL = 1
+TAP_TESTS = 1
+
+ifdef USE_PGXS
+PG_CONFIG = pg_config
+PGXS := $(shell $(PG_CONFIG) --pgxs)
+include $(PGXS)
+else
+subdir = src/test/modules/test_escape
+top_builddir = ../../../..
+include $(top_builddir)/src/Makefile.global
+include $(top_srcdir)/contrib/contrib-global.mk
+endif
+
+test_escape$(X): | submake-libpgfeutils
+check: test_escape$(X)
diff --git a/src/test/modules/test_escape/t/001_test_escape.pl b/src/test/modules/test_escape/t/001_test_escape.pl
new file mode 100644
index 00000000000..0d5aec3ed74
--- /dev/null
+++ b/src/test/modules/test_escape/t/001_test_escape.pl
@@ -0,0 +1,53 @@
+# Copyright (c) 2023-2025, PostgreSQL Global Development Group
+use strict;
+use warnings FATAL => 'all';
+use Config;
+use PostgreSQL::Test::Utils;
+use PostgreSQL::Test::Cluster;
+use Test::More;
+
+my $node = PostgreSQL::Test::Cluster->new('node');
+
+$node->init();
+$node->start();
+
+$node->safe_psql('postgres',
+	q(CREATE DATABASE db_sql_ascii ENCODING "sql_ascii" TEMPLATE template0;));
+
+my $cmd =
+  [ 'test_escape', '--conninfo', $node->connstr . " dbname=db_sql_ascii" ];
+
+# There currently is no good other way to transport test results from a C
+# program that requires just the node being set-up...
+my ($stderr, $stdout);
+my $result = IPC::Run::run $cmd, '>', \$stdout, '2>', \$stderr;
+
+is($result, 1, "test_escape returns 0");
+is($stderr, '', "test_escape stderr is empty");
+
+foreach my $line (split('\n', $stdout))
+{
+	if ($line =~ m/^ok \d+ ?(.*)/)
+	{
+		ok(1, $1);
+	}
+
+	elsif ($line =~ m/^not ok \d+ ?(.*)/)
+	{
+		ok(0, $1);
+	}
+
+	elsif ($line =~ m/^# ?(.*)/)
+	{
+		note $1;
+	}
+	elsif ($line =~ m/^\d+..\d+$/)
+	{
+	}
+	else
+	{
+		BAIL_OUT("no unmapped lines, got $line");
+	}
+}
+
+done_testing();
diff --git a/src/test/modules/test_escape/test_escape.c b/src/test/modules/test_escape/test_escape.c
new file mode 100644
index 00000000000..6654ab1dbe7
--- /dev/null
+++ b/src/test/modules/test_escape/test_escape.c
@@ -0,0 +1,803 @@
+/*
+ * test_escape.c Test escape functions
+ *
+ * Copyright (c) 2022-2025, PostgreSQL Global Development Group
+ *
+ * IDENTIFICATION
+ *		src/test/modules/test_escape/test_escape.c
+ */
+
+#include "postgres_fe.h"
+
+#include <string.h>
+#include <stdio.h>
+
+#include "fe_utils/psqlscan.h"
+#include "fe_utils/string_utils.h"
+#include "getopt_long.h"
+#include "libpq-fe.h"
+#include "mb/pg_wchar.h"
+
+
+typedef struct pe_test_config
+{
+	int			verbosity;
+	bool		force_unsupported;
+	const char *conninfo;
+	PGconn	   *conn;
+
+	int			test_count;
+	int			failure_count;
+} pe_test_config;
+
+
+/*
+ * An escape function to be tested by this test.
+ */
+typedef struct pe_test_escape_func
+{
+	const char *name;
+
+	/*
+	 * Can the escape method report errors? If so, we validate that it does in
+	 * case of various invalid inputs.
+	 */
+	bool		reports_errors;
+
+	/*
+	 * Is the escape method known to not handle invalidly encoded input? If
+	 * so, we don't run the test unless --force-unsupported is used.
+	 */
+	bool		supports_only_valid;
+
+	/*
+	 * Is the escape method known to only handle encodings where no byte in a
+	 * multi-byte characters are valid ascii.
+	 */
+	bool		supports_only_ascii_overlap;
+
+	bool		(*escape) (PGconn *conn, PQExpBuffer target,
+						   const char *unescaped, size_t unescaped_len,
+						   PQExpBuffer escape_err);
+} pe_test_escape_func;
+
+/*
+ * A single test input for this test.
+ */
+typedef struct pe_test_vector
+{
+	const char *client_encoding;
+	size_t		escape_len;
+	const char *escape;
+} pe_test_vector;
+
+
+/*
+ * Callback functions from flex lexer. Not currently used by the test.
+ */
+static const PsqlScanCallbacks test_scan_callbacks = {
+	NULL
+};
+
+
+static bool
+escape_literal(PGconn *conn, PQExpBuffer target,
+			   const char *unescaped, size_t unescaped_len,
+			   PQExpBuffer escape_err)
+{
+	char	   *escaped;
+
+	escaped = PQescapeLiteral(conn, unescaped, unescaped_len);
+	if (!escaped)
+	{
+		appendPQExpBuffer(escape_err, "%s",
+						  PQerrorMessage(conn));
+		escape_err->data[escape_err->len - 1] = 0;
+		escape_err->len--;
+		return false;
+	}
+	else
+	{
+		appendPQExpBufferStr(target, escaped);
+		PQfreemem(escaped);
+		return true;
+	}
+}
+
+static bool
+escape_identifier(PGconn *conn, PQExpBuffer target,
+				  const char *unescaped, size_t unescaped_len,
+				  PQExpBuffer escape_err)
+{
+	char	   *escaped;
+
+	escaped = PQescapeIdentifier(conn, unescaped, unescaped_len);
+	if (!escaped)
+	{
+		appendPQExpBuffer(escape_err, "%s",
+						  PQerrorMessage(conn));
+		escape_err->data[escape_err->len - 1] = 0;
+		escape_err->len--;
+		return false;
+	}
+	else
+	{
+		appendPQExpBufferStr(target, escaped);
+		PQfreemem(escaped);
+		return true;
+	}
+}
+
+static bool
+escape_string_conn(PGconn *conn, PQExpBuffer target,
+				   const char *unescaped, size_t unescaped_len,
+				   PQExpBuffer escape_err)
+{
+	int			error;
+	size_t		sz;
+
+	appendPQExpBufferChar(target, '\'');
+	enlargePQExpBuffer(target, unescaped_len * 2 + 1);
+	sz = PQescapeStringConn(conn, target->data + target->len,
+							unescaped, unescaped_len,
+							&error);
+
+	target->len += sz;
+	appendPQExpBufferChar(target, '\'');
+
+	if (error)
+	{
+		appendPQExpBuffer(escape_err, "%s",
+						  PQerrorMessage(conn));
+		escape_err->data[escape_err->len - 1] = 0;
+		escape_err->len--;
+		return false;
+	}
+	else
+	{
+		return true;
+	}
+}
+
+static bool
+escape_string(PGconn *conn, PQExpBuffer target,
+			  const char *unescaped, size_t unescaped_len,
+			  PQExpBuffer escape_err)
+{
+	size_t		sz;
+
+	appendPQExpBufferChar(target, '\'');
+	enlargePQExpBuffer(target, unescaped_len * 2 + 1);
+	sz = PQescapeString(target->data + target->len,
+						unescaped, unescaped_len);
+	target->len += sz;
+	appendPQExpBufferChar(target, '\'');
+
+
+	return true;
+}
+
+/*
+ * Escape via s/'/''/.  Non-core drivers invariably wrap libpq or use this
+ * method.  It suffices iff the input passes encoding validation, so it's
+ * marked as supports_only_valid.
+ */
+static bool
+escape_replace(PGconn *conn, PQExpBuffer target,
+			   const char *unescaped, size_t unescaped_len,
+			   PQExpBuffer escape_err)
+{
+	const char *s = unescaped;
+
+	appendPQExpBufferChar(target, '\'');
+
+	for (int i = 0; i < unescaped_len; i++)
+	{
+		char		c = *s;
+
+		if (c == '\'')
+		{
+			appendPQExpBufferStr(target, "''");
+		}
+		else
+			appendPQExpBufferChar(target, c);
+		s++;
+	}
+	appendPQExpBufferChar(target, '\'');
+
+	return true;
+}
+
+static bool
+escape_append_literal(PGconn *conn, PQExpBuffer target,
+					  const char *unescaped, size_t unescaped_len,
+					  PQExpBuffer escape_err)
+{
+	appendStringLiteral(target, unescaped, PQclientEncoding(conn), 1);
+
+	return true;
+}
+
+static bool
+escape_fmt_id(PGconn *conn, PQExpBuffer target,
+			  const char *unescaped, size_t unescaped_len,
+			  PQExpBuffer escape_err)
+{
+	setFmtEncoding(PQclientEncoding(conn));
+	appendPQExpBufferStr(target, fmtId(unescaped));
+
+	return true;
+}
+
+static pe_test_escape_func pe_test_escape_funcs[] =
+{
+	{
+		.name = "PQescapeLiteral",
+		.reports_errors = true,
+		.escape = escape_literal,
+	},
+	{
+		.name = "PQescapeIdentifier",
+		.reports_errors = true,
+		.escape = escape_identifier
+	},
+	{
+		.name = "PQescapeStringConn",
+		.reports_errors = true,
+		.escape = escape_string_conn
+	},
+	{
+		.name = "PQescapeString",
+		.reports_errors = false,
+		.escape = escape_string
+	},
+	{
+		.name = "replace",
+		.reports_errors = false,
+		.supports_only_valid = true,
+		.supports_only_ascii_overlap = true,
+		.escape = escape_replace
+	},
+	{
+		.name = "appendStringLiteral",
+		.reports_errors = false,
+		.escape = escape_append_literal
+	},
+	{
+		.name = "fmtId",
+		.reports_errors = false,
+		.escape = escape_fmt_id
+	},
+};
+
+
+#define TV(enc, string) {.client_encoding = (enc), .escape=string, .escape_len=sizeof(string) - 1, }
+static pe_test_vector pe_test_vectors[] =
+{
+	/* expected to work sanity checks */
+	TV("UTF-8", "1"),
+	TV("UTF-8", "'"),
+	TV("UTF-8", "\""),
+
+	TV("UTF-8", "\'"),
+	TV("UTF-8", "\""),
+
+	TV("UTF-8", "\\"),
+
+	TV("UTF-8", "\\'"),
+	TV("UTF-8", "\\\""),
+
+	/* trailing multi-byte character, paddable in available space */
+	TV("UTF-8", "1\xC0"),
+	TV("UTF-8", "1\xE0 "),
+	TV("UTF-8", "1\xF0 "),
+	TV("UTF-8", "1\xF0  "),
+	TV("UTF-8", "1\xF0   "),
+
+	/* trailing multi-byte character, not enough space to pad */
+	TV("UTF-8", "1\xE0"),
+	TV("UTF-8", "1\xF0"),
+	TV("UTF-8", "\xF0"),
+
+	/* try to smuggle in something in invalid characters */
+	TV("UTF-8", "1\xE0'"),
+	TV("UTF-8", "1\xE0\""),
+	TV("UTF-8", "1\xF0'"),
+	TV("UTF-8", "1\xF0\""),
+	TV("UTF-8", "1\xF0'; "),
+	TV("UTF-8", "1\xF0\"; "),
+	TV("UTF-8", "1\xF0';;;;"),
+	TV("UTF-8", "1\xF0  ';;;;"),
+	TV("UTF-8", "1\xF0  \";;;;"),
+	TV("UTF-8", "1\xE0'; \\l ; "),
+	TV("UTF-8", "1\xE0\"; \\l ; "),
+
+	/* null byte handling */
+	TV("UTF-8", "some\0thing"),
+	TV("UTF-8", "some\0"),
+	TV("UTF-8", "some\xF0'\0"),
+	TV("UTF-8", "some\xF0'\0'"),
+	TV("UTF-8", "some\xF0" "ab\0'"),
+
+	/* GB18030's 4 byte encoding requires a 2nd byte limited values */
+	TV("GB18030", "\x90\x31"),
+	TV("GB18030", "\\\x81\x5c'"),
+	TV("GB18030", "\\\x81\x5c\""),
+	TV("GB18030", "\\\x81\x5c\0'"),
+
+	/*
+	 * \x81 indicates a 2 byte char. ' and " are not a valid second byte, but
+	 * that requires encoding verification to know. E.g. replace_string()
+	 * doesn't cope.
+	 */
+	TV("GB18030", "\\\x81';"),
+	TV("GB18030", "\\\x81\";"),
+
+	/*
+	 * \x81 indicates a 2 byte char. \ is a valid second character.
+	 */
+	TV("GB18030", "\\\x81\\';"),
+	TV("GB18030", "\\\x81\\\";"),
+	TV("GB18030", "\\\x81\0;"),
+	TV("GB18030", "\\\x81\0'"),
+	TV("GB18030", "\\\x81'\0"),
+
+	TV("SJIS", "\xF0\x40;"),
+
+	TV("SJIS", "\xF0';"),
+	TV("SJIS", "\xF0\";"),
+	TV("SJIS", "\xF0\0'"),
+	TV("SJIS", "\\\xF0\\';"),
+	TV("SJIS", "\\\xF0\\\";"),
+
+	TV("gbk", "\x80';"),
+	TV("gbk", "\x80"),
+	TV("gbk", "\x80'"),
+	TV("gbk", "\x80\""),
+	TV("gbk", "\x80\\"),
+
+	TV("mule_internal", "\\\x9c';\0;"),
+
+	TV("sql_ascii", "1\xC0'"),
+};
+
+
+/*
+ * Print the string into buf, making characters outside of plain ascii
+ * somewhat easier to recognize.
+ *
+ * The output format could stand to be improved significantly, it's not at all
+ * unambiguous.
+ */
+static void
+escapify(PQExpBuffer buf, const char *str, size_t len)
+{
+	for (size_t i = 0; i < len; i++)
+	{
+		char		c = *str;
+
+		if (c == '\n')
+			appendPQExpBufferStr(buf, "\\n");
+		else if (c == '\0')
+			appendPQExpBufferStr(buf, "\\0");
+		else if (c < ' ' || c > '~')
+			appendPQExpBuffer(buf, "\\x%2x", (uint8_t) c);
+		else
+			appendPQExpBufferChar(buf, c);
+		str++;
+	}
+}
+
+static void
+report_result(pe_test_config *tc,
+			  bool success,
+			  PQExpBuffer testname,
+			  PQExpBuffer details,
+			  const char *subname,
+			  const char *resultdesc)
+{
+	int			test_id = ++tc->test_count;
+	bool		print_details = true;
+	bool		print_result = true;
+
+	if (success)
+	{
+		if (tc->verbosity <= 0)
+			print_details = false;
+		if (tc->verbosity < 0)
+			print_result = false;
+	}
+	else
+		tc->failure_count++;
+
+	if (print_details)
+		printf("%s", details->data);
+
+	if (print_result)
+		printf("%s %d - %s: %s: %s\n",
+			   success ? "ok" : "not ok",
+			   test_id, testname->data,
+			   subname,
+			   resultdesc);
+}
+
+/*
+ * Return true for encodings in which bytes in a multi-byte character look
+ * like valid ascii characters.
+ */
+static bool
+encoding_conflicts_ascii(int encoding)
+{
+	/*
+	 * We don't store this property directly anywhere, but whether an encoding
+	 * is a client-only encoding is a good proxy.
+	 */
+	if (encoding > PG_ENCODING_BE_LAST)
+		return true;
+	return false;
+}
+
+static const char *
+scan_res_s(PsqlScanResult res)
+{
+#define TOSTR_CASE(sym) case sym: return #sym
+
+	switch (res)
+	{
+			TOSTR_CASE(PSCAN_SEMICOLON);
+			TOSTR_CASE(PSCAN_BACKSLASH);
+			TOSTR_CASE(PSCAN_INCOMPLETE);
+			TOSTR_CASE(PSCAN_EOL);
+	}
+
+	pg_unreachable();
+	return "";					/* silence compiler */
+}
+
+/*
+ * Verify that psql parses the input as a single statement. If this property
+ * is violated, the escape function does not effectively protect against
+ * smuggling in a second statement.
+ */
+static void
+test_psql_parse(pe_test_config *tc, PQExpBuffer testname,
+				PQExpBuffer input_buf, PQExpBuffer details)
+{
+	PsqlScanState scan_state;
+	PsqlScanResult scan_result;
+	PQExpBuffer query_buf;
+	promptStatus_t prompt_status = PROMPT_READY;
+	int			matches = 0;
+	bool		test_fails;
+	const char *resdesc;
+
+	query_buf = createPQExpBuffer();
+
+	scan_state = psql_scan_create(&test_scan_callbacks);
+
+	/*
+	 * TODO: This hardcodes standard conforming strings, it would be useful to
+	 * test without as well.
+	 */
+	psql_scan_setup(scan_state, input_buf->data, input_buf->len,
+					PQclientEncoding(tc->conn), 1);
+
+	do
+	{
+		resetPQExpBuffer(query_buf);
+
+		scan_result = psql_scan(scan_state, query_buf,
+								&prompt_status);
+
+		appendPQExpBuffer(details,
+						  "#\t\t %d: scan_result: %s prompt: %u, query_buf: ",
+						  matches, scan_res_s(scan_result), prompt_status);
+		escapify(details, query_buf->data, query_buf->len);
+		appendPQExpBuffer(details, "\n");
+
+		matches++;
+	}
+	while (scan_result != PSCAN_INCOMPLETE && scan_result != PSCAN_EOL);
+
+	psql_scan_destroy(scan_state);
+	destroyPQExpBuffer(query_buf);
+
+	test_fails = matches > 1 || scan_result != PSCAN_EOL;
+
+	if (matches > 1)
+		resdesc = "more than one match";
+	else if (scan_result != PSCAN_EOL)
+		resdesc = "unexpected end state";
+	else
+		resdesc = "ok";
+
+	report_result(tc, !test_fails, testname, details,
+				  "psql parse",
+				  resdesc);
+}
+
+static void
+test_one_vector_escape(pe_test_config *tc, const pe_test_vector *tv, const pe_test_escape_func *ef)
+{
+	PQExpBuffer testname;
+	PQExpBuffer details;
+	PQExpBuffer escape_buf;
+	PQExpBuffer escape_err;
+	size_t		input_encoding_validlen;
+	bool		input_encoding_valid;
+	size_t		input_encoding0_validlen;
+	bool		input_encoding0_valid;
+	bool		escape_success;
+	size_t		escape_encoding_length;
+	bool		escape_encoding_valid;
+
+	escape_err = createPQExpBuffer();
+	testname = createPQExpBuffer();
+	details = createPQExpBuffer();
+	escape_buf = createPQExpBuffer();
+
+	if (ef->supports_only_ascii_overlap &&
+		encoding_conflicts_ascii(PQclientEncoding(tc->conn)))
+	{
+		goto out;
+	}
+
+	/* name to describe the test */
+	appendPQExpBuffer(testname, ">");
+	escapify(testname, tv->escape, tv->escape_len);
+	appendPQExpBuffer(testname, "< - %s - %s",
+					  tv->client_encoding, ef->name);
+
+	/* details to describe the test, to allow for debugging */
+	appendPQExpBuffer(details, "#\t input: %zd bytes: ",
+					  tv->escape_len);
+	escapify(details, tv->escape, tv->escape_len);
+	appendPQExpBufferStr(details, "\n");
+	appendPQExpBuffer(details, "#\t encoding: %s\n",
+					  tv->client_encoding);
+
+
+	/* check encoding of input, to compare with after the test */
+	input_encoding_validlen = pg_encoding_verifymbstr(PQclientEncoding(tc->conn),
+													  tv->escape,
+													  tv->escape_len);
+	input_encoding_valid = input_encoding_validlen == tv->escape_len;
+	appendPQExpBuffer(details, "#\t input encoding valid: %d\n",
+					  input_encoding_valid);
+
+	input_encoding0_validlen = pg_encoding_verifymbstr(PQclientEncoding(tc->conn),
+													   tv->escape,
+													   strlen(tv->escape));
+	input_encoding0_valid = input_encoding0_validlen == strlen(tv->escape);
+	appendPQExpBuffer(details, "#\t input encoding valid till 0: %d\n",
+					  input_encoding0_valid);
+
+	appendPQExpBuffer(details, "#\t escape func: %s\n",
+					  ef->name);
+
+	if (!input_encoding_valid && ef->supports_only_valid
+		&& !tc->force_unsupported)
+		goto out;
+
+
+	/* call the to-be-tested escape function */
+	escape_success = ef->escape(tc->conn, escape_buf,
+								tv->escape, tv->escape_len,
+								escape_err);
+	if (!escape_success)
+	{
+		appendPQExpBuffer(details, "#\t escape error: %s\n",
+						  escape_err->data);
+	}
+
+	if (escape_buf->len > 0)
+	{
+		appendPQExpBuffer(details, "#\t escaped string: %zd bytes: ", escape_buf->len);
+		escapify(details, escape_buf->data, escape_buf->len);
+		appendPQExpBufferChar(details, '\n');
+
+		escape_encoding_length = pg_encoding_verifymbstr(PQclientEncoding(tc->conn),
+														 escape_buf->data,
+														 escape_buf->len);
+		escape_encoding_valid = escape_encoding_length == escape_buf->len;
+
+		appendPQExpBuffer(details, "#\t escape encoding valid: %d\n",
+						  escape_encoding_valid);
+	}
+	else
+	{
+		escape_encoding_length = 0;
+		escape_encoding_valid = 1;
+	}
+
+	/*
+	 * If the test reports errors, and the input was invalidly encoded,
+	 * escaping should fail.  One edge-case that we accept for now is that the
+	 * input could have an embedded null byte, which the escape functions will
+	 * just treat as a shorter string. If the encoding error is after the zero
+	 * byte, the output thus won't contain it.
+	 */
+	if (ef->reports_errors)
+	{
+		bool		ok = true;
+		const char *resdesc = "ok";
+
+		if (escape_success)
+		{
+			if (!input_encoding0_valid)
+			{
+				ok = false;
+				resdesc = "invalid input escaped successfully";
+			}
+			else if (!input_encoding_valid)
+				resdesc = "invalid input escaped successfully, due to zero byte";
+		}
+		else
+		{
+			if (input_encoding0_valid)
+			{
+				ok = false;
+				resdesc = "valid input failed to escape";
+			}
+			else if (input_encoding_valid)
+				resdesc = "valid input failed to escape, due to zero byte";
+		}
+
+		report_result(tc, ok, testname, details,
+					  "input validity vs escape success",
+					  resdesc);
+	}
+
+	/*
+	 * If the input is invalidly encoded, the output should also be invalidly
+	 * encoded. We accept the same zero-byte edge case as above.
+	 */
+	{
+		bool		ok = true;
+		const char *resdesc = "ok";
+
+		if (input_encoding0_valid && !input_encoding_valid && escape_encoding_valid)
+		{
+			resdesc = "invalid input produced valid output, due to zero byte";
+		}
+		else if (input_encoding0_valid && !escape_encoding_valid)
+		{
+			ok = false;
+			resdesc = "valid input produced invalid output";
+		}
+		else if (!input_encoding0_valid &&
+				 (!ef->reports_errors || escape_success) &&
+				 escape_encoding_valid)
+		{
+			ok = false;
+			resdesc = "invalid input produced valid output";
+		}
+
+		report_result(tc, ok, testname, details,
+					  "input and escaped encoding validity",
+					  resdesc);
+	}
+
+	/*
+	 * Test psql parsing whenever we get any string back, even if the escape
+	 * function returned a failure.
+	 */
+	if (escape_buf->len > 0)
+	{
+		test_psql_parse(tc, testname,
+						escape_buf, details);
+	}
+
+out:
+	destroyPQExpBuffer(escape_err);
+	destroyPQExpBuffer(details);
+	destroyPQExpBuffer(testname);
+	destroyPQExpBuffer(escape_buf);
+}
+
+static void
+test_one_vector(pe_test_config *tc, const pe_test_vector *tv)
+{
+	if (PQsetClientEncoding(tc->conn, tv->client_encoding))
+	{
+		fprintf(stderr, "failed to set encoding to %s:\n%s\n",
+				tv->client_encoding, PQerrorMessage(tc->conn));
+		exit(1);
+	}
+
+	for (int escoff = 0; escoff < lengthof(pe_test_escape_funcs); escoff++)
+	{
+		const pe_test_escape_func *ef = &pe_test_escape_funcs[escoff];
+
+		test_one_vector_escape(tc, tv, ef);
+	}
+}
+
+static void
+usage(const char *hint)
+{
+	if (hint)
+		fprintf(stderr, "Error: %s\n\n", hint);
+
+	printf("PostgreSQL escape function test\n"
+		   "\n"
+		   "Usage:\n"
+		   "  test_escape --conninfo=CONNINFO [OPTIONS]\n"
+		   "\n"
+		   "Options:\n"
+		   "  -h, --help                show this help\n"
+		   "  -c, --conninfo=CONNINFO   connection information to use\n"
+		   "  -v, --verbose             show test details even for successes\n"
+		   "  -q, --quiet               only show failures\n"
+		   "      --force-unsupported   test invalid input even if unsupported\n"
+		);
+
+	if (hint)
+		exit(1);
+}
+
+int
+main(int argc, char *argv[])
+{
+	pe_test_config tc = {0};
+	char		c;
+	int			option_index;
+
+	static const struct option long_options[] = {
+		{"help", no_argument, NULL, 'h'},
+		{"conninfo", required_argument, NULL, 'c'},
+		{"verbose", no_argument, NULL, 'v'},
+		{"quiet", no_argument, NULL, 'q'},
+		{"force-unsupported", no_argument, NULL, 'f'},
+		{NULL, 0, NULL, 0},
+	};
+
+	while ((c = getopt_long(argc, argv, "vqh", long_options, &option_index)) != -1)
+	{
+		switch (c)
+		{
+			case 'h':
+				usage(NULL);
+				exit(0);
+				break;
+			case 'c':
+				tc.conninfo = optarg;
+				break;
+			case 'v':
+				tc.verbosity++;
+				break;
+			case 'q':
+				tc.verbosity--;
+				break;
+			case 'f':
+				tc.force_unsupported = true;
+				break;
+		}
+	}
+
+	if (argc - optind >= 1)
+		usage("unused option(s) specified");
+
+	if (tc.conninfo == NULL)
+		usage("--conninfo needs to be specified");
+
+	tc.conn = PQconnectdb(tc.conninfo);
+
+	if (!tc.conn || PQstatus(tc.conn) != CONNECTION_OK)
+	{
+		fprintf(stderr, "could not connect: %s\n",
+				PQerrorMessage(tc.conn));
+		exit(1);
+	}
+
+	for (int i = 0; i < lengthof(pe_test_vectors); i++)
+	{
+		test_one_vector(&tc, &pe_test_vectors[i]);
+	}
+
+	PQfinish(tc.conn);
+
+	printf("# %d failures\n", tc.failure_count);
+	printf("1..%d\n", tc.test_count);
+	return tc.failure_count > 0;
+}
diff --git a/src/tools/msvc/Mkvcbuild.pm b/src/tools/msvc/Mkvcbuild.pm
index f86a065375f..3cbc8a83984 100644
--- a/src/tools/msvc/Mkvcbuild.pm
+++ b/src/tools/msvc/Mkvcbuild.pm
@@ -50,7 +50,7 @@ my @contrib_excludes       = (
 	'sepgsql',         'brin',
 	'test_extensions', 'test_misc',
 	'test_pg_dump',    'snapshot_too_old',
-	'unsafe_tests');
+	'unsafe_tests',    'test_escape');
 
 # Set of variables for frontend modules
 my $frontend_defines = { 'initdb' => 'FRONTEND' };
diff --git a/src/tools/pgindent/typedefs.list b/src/tools/pgindent/typedefs.list
index cb077fd0d52..2fb88042e81 100644
--- a/src/tools/pgindent/typedefs.list
+++ b/src/tools/pgindent/typedefs.list
@@ -3452,6 +3452,9 @@ parallel_worker_main_type
 parse_error_callback_arg
 parser_context
 partition_method_t
+pe_test_config
+pe_test_escape_func
+pe_test_vector
 pendingPosition
 pgParameterStatus
 pg_atomic_flag
-- 
2.43.0


From 57bda2508f1c666fd18f2b233823b7c98308226b Mon Sep 17 00:00:00 2001
From: Andres Freund <andres@anarazel.de>
Date: Mon, 10 Feb 2025 10:03:39 -0500
Subject: [PATCH 93/97] docs: EUC_TW can be up to four bytes wide, not three

Backpatch-through: 13
Security: CVE-2025-1094
---
 doc/src/sgml/charset.sgml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/doc/src/sgml/charset.sgml b/doc/src/sgml/charset.sgml
index c152bd9306a..8933c2ff03d 100644
--- a/doc/src/sgml/charset.sgml
+++ b/doc/src/sgml/charset.sgml
@@ -1168,7 +1168,7 @@ CREATE COLLATION ignore_accents (provider = icu, locale = 'und-u-ks-level1-kc-tr
          <entry>Traditional Chinese, Taiwanese</entry>
          <entry>Yes</entry>
          <entry>Yes</entry>
-         <entry>1&ndash;3</entry>
+         <entry>1&ndash;4</entry>
          <entry></entry>
         </row>
         <row>
-- 
2.43.0


From a085fa73169d6c0df079cfa4ddfeade812368a64 Mon Sep 17 00:00:00 2001
From: Andres Freund <andres@anarazel.de>
Date: Mon, 10 Feb 2025 12:09:23 -0500
Subject: [PATCH 94/97] Fix type in test_escape test

On machines where char is unsigned this could lead to option parsing looping
endlessly. It's also too narrow a type on other hardware.

Found via Tom Lane's monitoring of the buildfarm.

Reported-by: Tom Lane <tgl@sss.pgh.pa.us>
Security: CVE-2025-1094
Backpatch-through: 13
---
 src/test/modules/test_escape/test_escape.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/test/modules/test_escape/test_escape.c b/src/test/modules/test_escape/test_escape.c
index 6654ab1dbe7..3ed70436155 100644
--- a/src/test/modules/test_escape/test_escape.c
+++ b/src/test/modules/test_escape/test_escape.c
@@ -740,7 +740,7 @@ int
 main(int argc, char *argv[])
 {
 	pe_test_config tc = {0};
-	char		c;
+	int			c;
 	int			option_index;
 
 	static const struct option long_options[] = {
-- 
2.43.0


From 9862de9176ef161e20a40f327afe18c6a11ecdcc Mon Sep 17 00:00:00 2001
From: Tom Lane <tgl@sss.pgh.pa.us>
Date: Mon, 10 Feb 2025 16:30:03 -0500
Subject: [PATCH 95/97] Adapt appendPsqlMetaConnect() to the new fmtId()
 encoding expectations.

We need to tell fmtId() what encoding to assume, but this function
doesn't know that.  Fortunately we can fix that without changing the
function's API, because we can just use SQL_ASCII.  That's because
database names in connection requests are effectively binary not text:
no encoding-aware processing will happen on them.

This fixes XversionUpgrade failures seen in the buildfarm.  The
alternative of having pg_upgrade use setFmtEncoding() is unappetizing,
given that it's connecting to multiple databases that may have
different encodings.

Andres Freund, Noah Misch, Tom Lane

Security: CVE-2025-1094
---
 src/fe_utils/string_utils.c | 19 ++++++++++++++-----
 1 file changed, 14 insertions(+), 5 deletions(-)

diff --git a/src/fe_utils/string_utils.c b/src/fe_utils/string_utils.c
index 99128d74160..78f6df24089 100644
--- a/src/fe_utils/string_utils.c
+++ b/src/fe_utils/string_utils.c
@@ -790,29 +790,38 @@ appendPsqlMetaConnect(PQExpBuffer buf, const char *dbname)
 		}
 	}
 
-	appendPQExpBufferStr(buf, "\\connect ");
 	if (complex)
 	{
 		PQExpBufferData connstr;
 
 		initPQExpBuffer(&connstr);
+
+		/*
+		 * Force the target psql's encoding to SQL_ASCII.  We don't really
+		 * know the encoding of the database name, and it doesn't matter as
+		 * long as psql will forward it to the server unchanged.
+		 */
+		appendPQExpBufferStr(buf, "\\encoding SQL_ASCII\n");
+		appendPQExpBufferStr(buf, "\\connect -reuse-previous=on ");
+
 		appendPQExpBufferStr(&connstr, "dbname=");
 		appendConnStrVal(&connstr, dbname);
 
-		appendPQExpBufferStr(buf, "-reuse-previous=on ");
-
 		/*
 		 * As long as the name does not contain a newline, SQL identifier
 		 * quoting satisfies the psql meta-command parser.  Prefer not to
 		 * involve psql-interpreted single quotes, which behaved differently
 		 * before PostgreSQL 9.2.
 		 */
-		appendPQExpBufferStr(buf, fmtId(connstr.data));
+		appendPQExpBufferStr(buf, fmtIdEnc(connstr.data, PG_SQL_ASCII));
 
 		termPQExpBuffer(&connstr);
 	}
 	else
-		appendPQExpBufferStr(buf, fmtId(dbname));
+	{
+		appendPQExpBufferStr(buf, "\\connect ");
+		appendPQExpBufferStr(buf, fmtIdEnc(dbname, PG_SQL_ASCII));
+	}
 	appendPQExpBufferChar(buf, '\n');
 }
 
-- 
2.43.0


