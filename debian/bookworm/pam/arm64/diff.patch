From 031bb5a5d0d950253b68138b498dc93be69a64cb Mon Sep 17 00:00:00 2001
From: Matthias Gerstner <matthias.gerstner@suse.de>
Date: Wed, 27 Dec 2023 14:01:59 +0100
Subject: [PATCH] pam_namespace: protect_dir(): use O_DIRECTORY to prevent
 local DoS situations

Without O_DIRECTORY the path crawling logic is subject to e.g. FIFOs
being placed in user controlled directories, causing the PAM module to
block indefinitely during `openat()`.

Pass O_DIRECTORY to cause the `openat()` to fail if the path does not
refer to a directory.

With this the check whether the final path element is a directory
becomes unnecessary, drop it.
---
 modules/pam_namespace/pam_namespace.c | 18 +-----------------
 1 file changed, 1 insertion(+), 17 deletions(-)

diff --git a/modules/pam_namespace/pam_namespace.c b/modules/pam_namespace/pam_namespace.c
index 2528cff86d..f72d671890 100644
--- a/modules/pam_namespace/pam_namespace.c
+++ b/modules/pam_namespace/pam_namespace.c
@@ -1201,7 +1201,7 @@ static int protect_dir(const char *path, mode_t mode, int do_mkdir,
 	int dfd = AT_FDCWD;
 	int dfd_next;
 	int save_errno;
-	int flags = O_RDONLY;
+	int flags = O_RDONLY | O_DIRECTORY;
 	int rv = -1;
 	struct stat st;
 
@@ -1255,22 +1255,6 @@ static int protect_dir(const char *path, mode_t mode, int do_mkdir,
 		rv = openat(dfd, dir, flags);
 	}
 
-	if (rv != -1) {
-		if (fstat(rv, &st) != 0) {
-			save_errno = errno;
-			close(rv);
-			rv = -1;
-			errno = save_errno;
-			goto error;
-		}
-		if (!S_ISDIR(st.st_mode)) {
-			close(rv);
-			errno = ENOTDIR;
-			rv = -1;
-			goto error;
-		}
-	}
-
 	if (flags & O_NOFOLLOW) {
 		/* we are inside user-owned dir - protect */
 		if (protect_mount(rv, p, idata) == -1) {
From 8750c069dbbf7106a2dbf799c65ae62f807f73a3 Mon Sep 17 00:00:00 2001
From: Amal C S <amalcs@focaloid.com>
Date: Thu, 26 Jun 2025 15:18:51 +0530
Subject: [PATCH] FIX: CVE-2025-6020

---
 libpam/include/pam_cc_compat.h        |  26 +-
 libpam/include/pam_inline.h           |  49 ++
 modules/pam_namespace/namespace.init  |  56 +-
 modules/pam_namespace/pam_namespace.c | 920 ++++++++++++++++++--------
 modules/pam_namespace/pam_namespace.h |  10 +
 5 files changed, 748 insertions(+), 313 deletions(-)

diff --git a/libpam/include/pam_cc_compat.h b/libpam/include/pam_cc_compat.h
index 69190368..af054283 100644
--- a/libpam/include/pam_cc_compat.h
+++ b/libpam/include/pam_cc_compat.h
@@ -21,6 +21,12 @@
 # define PAM_ATTRIBUTE_ALIGNED(arg)	/* empty */
 #endif
 
+#if PAM_GNUC_PREREQ(3, 0)
+# define PAM_ATTRIBUTE_MALLOC		__attribute__((__malloc__))
+#else
+# define PAM_ATTRIBUTE_MALLOC		/* empty */
+#endif
+
 #if PAM_GNUC_PREREQ(4, 6)
 # define DIAG_PUSH_IGNORE_CAST_QUAL					\
 	_Pragma("GCC diagnostic push");					\
@@ -32,6 +38,11 @@
 	_Pragma("GCC diagnostic ignored \"-Wcast-align\"")
 # define DIAG_POP_IGNORE_CAST_ALIGN					\
 	_Pragma("GCC diagnostic pop")
+# define DIAG_PUSH_IGNORE_FORMAT_NONLITERAL				\
+	_Pragma("GCC diagnostic push");					\
+	_Pragma("GCC diagnostic ignored \"-Wformat-nonliteral\"")
+# define DIAG_POP_IGNORE_FORMAT_NONLITERAL				\
+	_Pragma("GCC diagnostic pop")
 #elif PAM_CLANG_PREREQ(2, 6)
 # define DIAG_PUSH_IGNORE_CAST_QUAL					\
 	_Pragma("clang diagnostic push");				\
@@ -43,11 +54,18 @@
 	_Pragma("clang diagnostic ignored \"-Wcast-align\"")
 # define DIAG_POP_IGNORE_CAST_ALIGN					\
 	_Pragma("clang diagnostic pop")
+# define DIAG_PUSH_IGNORE_FORMAT_NONLITERAL				\
+	_Pragma("clang diagnostic push");				\
+	_Pragma("clang diagnostic ignored \"-Wformat-nonliteral\"")
+# define DIAG_POP_IGNORE_FORMAT_NONLITERAL				\
+	_Pragma("clang diagnostic pop")
 #else
-# define DIAG_PUSH_IGNORE_CAST_QUAL	/* empty */
-# define DIAG_POP_IGNORE_CAST_QUAL	/* empty */
-# define DIAG_PUSH_IGNORE_CAST_ALIGN	/* empty */
-# define DIAG_POP_IGNORE_CAST_ALIGN	/* empty */
+# define DIAG_PUSH_IGNORE_CAST_QUAL		/* empty */
+# define DIAG_POP_IGNORE_CAST_QUAL		/* empty */
+# define DIAG_PUSH_IGNORE_CAST_ALIGN		/* empty */
+# define DIAG_POP_IGNORE_CAST_ALIGN		/* empty */
+# define DIAG_PUSH_IGNORE_FORMAT_NONLITERAL	/* empty */
+# define DIAG_POP_IGNORE_FORMAT_NONLITERAL	/* empty */
 #endif
 
 /*
diff --git a/libpam/include/pam_inline.h b/libpam/include/pam_inline.h
index ec2f3bf0..3d07417a 100644
--- a/libpam/include/pam_inline.h
+++ b/libpam/include/pam_inline.h
@@ -9,6 +9,9 @@
 #define PAM_INLINE_H
 
 #include "pam_cc_compat.h"
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 #include <errno.h>
@@ -34,9 +37,18 @@
  */
 #define PAM_MUST_BE_ARRAY(a_)		PAM_FAIL_BUILD_ON_ZERO(!PAM_IS_NOT_ARRAY(a_))
 
+/*
+ * Evaluates to
+ * - a syntax error if the argument is an array,
+ * 0, otherwise.
+ */
+#define PAM_MUST_NOT_BE_ARRAY(a_)	PAM_FAIL_BUILD_ON_ZERO(PAM_IS_NOT_ARRAY(a_))
+
 /* Evaluates to the number of elements in the specified array.  */
 #define PAM_ARRAY_SIZE(a_)		(sizeof(a_) / sizeof((a_)[0]) + PAM_MUST_BE_ARRAY(a_))
 
+
+
 /*
  * Returns NULL if STR does not start with PREFIX,
  * or a pointer to the first char in STR after PREFIX.
@@ -66,6 +78,41 @@ pam_str_skip_icase_prefix_len(const char *str, const char *prefix, size_t prefix
 #define pam_str_skip_icase_prefix(str_, prefix_)	\
 	pam_str_skip_icase_prefix_len((str_), (prefix_), sizeof(prefix_) - 1 + PAM_MUST_BE_ARRAY(prefix_))
 
+
+
+static inline char * PAM_FORMAT((printf, 1, 2)) PAM_NONNULL((1)) PAM_ATTRIBUTE_MALLOC
+pam_asprintf(const char *fmt, ...)
+{
+	int rc;
+	char *res;
+	va_list ap;
+
+	va_start(ap, fmt);
+	rc = vasprintf(&res, fmt, ap);
+	va_end(ap);
+
+	return rc < 0 ? NULL : res;
+}
+
+static inline int PAM_FORMAT((printf, 3, 4)) PAM_NONNULL((3))
+pam_snprintf(char *str, size_t size, const char *fmt, ...)
+{
+	int rc;
+	va_list ap;
+
+	va_start(ap, fmt);
+	rc = vsnprintf(str, size, fmt, ap);
+	va_end(ap);
+
+	if (rc < 0 || (unsigned int) rc >= size)
+		return -1;
+	return rc;
+}
+
+#define pam_sprintf(str_, fmt_, ...)						\
+	pam_snprintf((str_), sizeof(str_) + PAM_MUST_BE_ARRAY(str_), (fmt_),	\
+		     ##__VA_ARGS__)
+
 static inline int
 pam_read_passwords(int fd, int npass, char **passwords)
 {
@@ -115,4 +162,6 @@ pam_read_passwords(int fd, int npass, char **passwords)
 	return i;
 }
 
+
+
 #endif /* PAM_INLINE_H */
diff --git a/modules/pam_namespace/namespace.init b/modules/pam_namespace/namespace.init
index 67d4aa2d..8782178f 100755
--- a/modules/pam_namespace/namespace.init
+++ b/modules/pam_namespace/namespace.init
@@ -1,25 +1,43 @@
 #!/bin/sh
-# It receives polydir path as $1, the instance path as $2,
-# a flag whether the instance dir was newly created (0 - no, 1 - yes) in $3,
-# and user name in $4.
+# It receives as arguments:
+# - $1 polydir path (see WARNING below)
+# - $2 instance path (see WARNING below)
+# - $3 flag whether the instance dir was newly created (0 - no, 1 - yes)
+# - $4 user name
+# - $5 flag whether the polydir path ($1) is safe (0 - unsafe, 1 -safe)
+# - $6 flag whether the instance path ($2) is safe (0 - unsafe, 1 - safe)
+#
+# WARNING: This script is invoked with full root privileges. Accessing
+# the polydir ($1) and the instance ($2) directories in this context may be
+# extremely dangerous as those can be under user control. The flags $5 and $6
+# are provided to let you know if all the segments part of the path (except the
+# last one) are owned by root and are writable by root only. If the path does
+# not meet these criteria, you expose yourself to possible symlink attacks when
+# accessing these path.
+# However, even if the path components are safe, the content of the
+# directories may still be owned/writable by a user, so care must be taken!
 #
 # The following section will copy the contents of /etc/skel if this is a
 # newly created home directory.
-if [ "$3" = 1 ]; then
-        # This line will fix the labeling on all newly created directories
-        [ -x /sbin/restorecon ] && /sbin/restorecon "$1"
-        user="$4"
-        passwd=$(getent passwd "$user")
-        homedir=$(echo "$passwd" | cut -f6 -d":")
-        if [ "$1" = "$homedir" ]; then
-                gid=$(echo "$passwd" | cut -f4 -d":")
-                cp -rT /etc/skel "$homedir"
-                chown -R "$user":"$gid" "$homedir"
-                mask=$(awk '/^UMASK/{gsub("#.*$", "", $2); print $2; exit}' /etc/login.defs)
-                mode=$(printf "%o" $((0777 & ~$mask)))
-                chmod ${mode:-700} "$homedir"
-                [ -x /sbin/restorecon ] && /sbin/restorecon -R "$homedir"
-        fi
-fi
 
+# Executes only if the polydir path is safe
+if [ "$5" = 1 ]; then
+
+    if [ "$3" = 1 ]; then
+            # This line will fix the labeling on all newly created directories
+            [ -x /sbin/restorecon ] && /sbin/restorecon "$1"
+            user="$4"
+            passwd=$(getent passwd "$user")
+            homedir=$(echo "$passwd" | cut -f6 -d":")
+            if [ "$1" = "$homedir" ]; then
+                    gid=$(echo "$passwd" | cut -f4 -d":")
+                    cp -rT /etc/skel "$homedir"
+                    chown -R "$user":"$gid" "$homedir"
+                    mask=$(sed -E -n 's/^UMASK[[:space:]]+([^#[:space:]]+).*/\1/p' /etc/login.defs)
+                    mode=$(printf "%o" $((0777 & ~mask)))
+                    chmod ${mode:-700} "$homedir"
+                    [ -x /sbin/restorecon ] && /sbin/restorecon -R "$homedir"
+            fi
+    fi
+fi
 exit 0
diff --git a/modules/pam_namespace/pam_namespace.c b/modules/pam_namespace/pam_namespace.c
index d6b1d3c5..00d7ec06 100644
--- a/modules/pam_namespace/pam_namespace.c
+++ b/modules/pam_namespace/pam_namespace.c
@@ -39,6 +39,299 @@
 #include "pam_namespace.h"
 #include "argv_parse.h"
 
+#define MAGIC_LNK_FD_SIZE 64
+
+/* --- evaluating all files in VENDORDIR/security/namespace.d and /etc/security/namespace.d --- */
+static const char *base_name(const char *path)
+{
+    const char *base = strrchr(path, '/');
+    return base ? base+1 : path;
+}
+
+static int
+compare_filename(const void *a, const void *b)
+{
+	return strcmp(base_name(* (char * const *) a),
+		      base_name(* (char * const *) b));
+}
+
+static void close_fds_pre_exec(struct instance_data *idata)
+{
+	if (pam_modutil_sanitize_helper_fds(idata->pamh, PAM_MODUTIL_IGNORE_FD,
+			PAM_MODUTIL_IGNORE_FD, PAM_MODUTIL_IGNORE_FD) < 0) {
+		_exit(1);
+	}
+}
+
+static void
+strip_trailing_slashes(char *str)
+{
+	char *p = str + strlen(str);
+
+	while (--p > str && *p == '/')
+		*p = '\0';
+}
+
+static int protect_mount(int dfd, const char *path, struct instance_data *idata)
+{
+	struct protect_dir_s *dir = idata->protect_dirs;
+	char tmpbuf[MAGIC_LNK_FD_SIZE];
+
+	while (dir != NULL) {
+		if (strcmp(path, dir->dir) == 0) {
+			return 0;
+		}
+		dir = dir->next;
+	}
+
+	if (pam_sprintf(tmpbuf, "/proc/self/fd/%d", dfd) < 0)
+		return -1;
+
+	dir = calloc(1, sizeof(*dir));
+
+	if (dir == NULL) {
+		return -1;
+	}
+
+	dir->dir = strdup(path);
+
+	if (dir->dir == NULL) {
+		free(dir);
+		return -1;
+	}
+
+	if (idata->flags & PAMNS_DEBUG) {
+		pam_syslog(idata->pamh, LOG_INFO,
+			"Protect mount of %s over itself", path);
+	}
+
+	if (mount(tmpbuf, tmpbuf, NULL, MS_BIND, NULL) != 0) {
+		int save_errno = errno;
+		pam_syslog(idata->pamh, LOG_ERR,
+			"Protect mount of %s failed: %m", tmpbuf);
+		free(dir->dir);
+		free(dir);
+		errno = save_errno;
+		return -1;
+	}
+
+	dir->next = idata->protect_dirs;
+	idata->protect_dirs = dir;
+
+	return 0;
+}
+
+/*
+ * Returns a fd to the given absolute path, acquired securely. This means:
+ * - iterating on each segment of the path,
+ * - not following user symlinks,
+ * - using race-free operations.
+ *
+ * Takes a bit mask to specify the operation mode:
+ * - SECURE_OPENDIR_PROTECT: call protect_mount() on each unsafe segment of path
+ * - SECURE_OPENDIR_MKDIR: create last segment of path if does not exist
+ * - SECURE_OPENDIR_FULL_FD: open the directory with O_RDONLY instead of O_PATH,
+ *     allowing more operations to be done with the returned fd
+ *
+ * Be aware that using SECURE_OPENDIR_PROTECT:
+ * - will modify some external state (global structure...) and should not be
+ *   called in cleanup code paths. See wrapper secure_opendir_stateless()
+ * - need a non-NULL idata to call protect_mount()
+ */
+static int secure_opendir(const char *path, int opm, mode_t mode,
+	struct instance_data *idata)
+{
+	char *p;
+	char *d;
+	char *dir;
+	int dfd = -1;
+	int dfd_next;
+	int save_errno;
+	int flags = O_DIRECTORY | O_CLOEXEC;
+	int rv = -1;
+	struct stat st;
+
+	if (opm & SECURE_OPENDIR_FULL_FD)
+		flags |= O_RDONLY;
+	else
+		flags |= O_PATH;
+
+	/* Check for args consistency */
+	if ((opm & SECURE_OPENDIR_PROTECT) && idata == NULL)
+		return -1;
+
+	/* Accept only absolute paths */
+	if (*path != '/')
+		return -1;
+
+	dir = p = strdup(path);
+	if (p == NULL)
+		return -1;
+
+	/* Assume '/' is safe */
+	dfd = open("/", flags);
+	if (dfd == -1)
+		goto error;
+
+	/* Needed to not loop too far and call openat() on NULL */
+	strip_trailing_slashes(p);
+
+	dir++;
+
+	/* In case path is '/' */
+	if (*dir == '\0') {
+		free(p);
+		return dfd;
+	}
+
+	while ((d=strchr(dir, '/')) != NULL) {
+		*d = '\0';
+
+		dfd_next = openat(dfd, dir, flags);
+		if (dfd_next == -1)
+			goto error;
+
+		if (fstat(dfd_next, &st) != 0) {
+			close(dfd_next);
+			goto error;
+		}
+
+		if ((flags & O_NOFOLLOW) && (opm & SECURE_OPENDIR_PROTECT)) {
+			/* we are inside user-owned dir - protect */
+			if (protect_mount(dfd_next, p, idata) == -1) {
+				close(dfd_next);
+				goto error;
+			}
+			/*
+			 * Reopen the directory to obtain a new descriptor
+			 * after protect_mount(), this is necessary in cases
+			 * when another directory is going to be mounted over
+			 * the given path.
+			 */
+			close(dfd_next);
+			dfd_next = openat(dfd, dir, flags);
+			if (dfd_next == -1)
+				goto error;
+		} else if (st.st_uid != 0
+		           || (st.st_mode & (S_IWGRP|S_IWOTH))) {
+			/* do not follow symlinks on subdirectories */
+			flags |= O_NOFOLLOW;
+		}
+
+		close(dfd);
+		dfd = dfd_next;
+
+		*d = '/';
+		dir = d + 1;
+	}
+
+	rv = openat(dfd, dir, flags);
+
+	if (rv == -1) {
+		if ((opm & SECURE_OPENDIR_MKDIR) && mkdirat(dfd, dir, mode) == 0)
+			rv = openat(dfd, dir, flags);
+
+		if (rv == -1)
+			goto error;
+	}
+
+	if ((flags & O_NOFOLLOW) && (opm & SECURE_OPENDIR_PROTECT)) {
+		/* we are inside user-owned dir - protect */
+		if (protect_mount(rv, p, idata) == -1) {
+			save_errno = errno;
+			close(rv);
+			rv = -1;
+			errno = save_errno;
+		}
+		/*
+		 * Reopen the directory to obtain a new descriptor after
+		 * protect_mount(), this is necessary in cases when another
+		 * directory is going to be mounted over the given path.
+		 */
+		close(rv);
+		rv = openat(dfd, dir, flags);
+	}
+
+error:
+	save_errno = errno;
+	free(p);
+	if (dfd >= 0)
+		close(dfd);
+	errno = save_errno;
+
+	return rv;
+}
+
+/*
+ * Returns a fd to the given path, acquired securely.
+ * It can be called in all situations, including in cleanup code paths, as
+ * it does not modify external state (no access to global structures...).
+ */
+static int secure_opendir_stateless(const char *path)
+{
+	return secure_opendir(path, 0, 0, NULL);
+}
+
+/*
+ * Umount securely the given path, even if the directories along
+ * the path are under user control. It should protect against
+ * symlinks attacks and race conditions.
+ */
+static int secure_umount(const char *path)
+{
+	int save_errno;
+	int rv = -1;
+	int dfd = -1;
+	char s_path[MAGIC_LNK_FD_SIZE];
+
+	dfd = secure_opendir_stateless(path);
+	if (dfd == -1)
+		return rv;
+
+	if (pam_sprintf(s_path, "/proc/self/fd/%d", dfd) < 0)
+		goto error;
+
+	/*
+	* We still have a fd open to path itself,
+	* so we need to do a lazy umount.
+	*/
+	rv = umount2(s_path, MNT_DETACH);
+
+error:
+	save_errno = errno;
+	close(dfd);
+	errno = save_errno;
+	return rv;
+}
+
+/*
+ * Rmdir the given path securely, protecting against symlinks attacks
+ * and race conditions.
+ * This function is currently called only in cleanup code paths where
+ * any errors returned are not handled, so do not handle them either.
+ * Basically, try to rmdir the path on a best-effort basis.
+ */
+static void secure_try_rmdir(const char *path)
+{
+	int dfd;
+	char *buf;
+	char *parent;
+
+	buf = strdup(path);
+	if (buf == NULL)
+		return;
+
+	parent = dirname(buf);
+
+	dfd = secure_opendir_stateless(parent);
+	if (dfd >= 0) {
+		unlinkat(dfd, base_name(path), AT_REMOVEDIR);
+		close(dfd);
+	}
+
+	free(buf);
+}
+
 /*
  * Adds an entry for a polyinstantiated directory to the linked list of
  * polyinstantiated directories. It is called from process_line() while
@@ -90,7 +383,7 @@ static void unprotect_dirs(struct protect_dir_s *dir)
 	struct protect_dir_s *next;
 
 	while (dir != NULL) {
-		umount(dir->dir);
+		secure_umount(dir->dir);
 		free(dir->dir);
 		next = dir->next;
 		free(dir);
@@ -119,7 +412,7 @@ static char *expand_variables(const char *orig, const char *var_names[], const c
 		if (*src == '$') {
 			int i;
 			for (i = 0; var_names[i]; i++) {
-				int namelen = strlen(var_names[i]);
+				size_t namelen = strlen(var_names[i]);
 				if (strncmp(var_names[i], src+1, namelen) == 0) {
 					dstlen += strlen(var_values[i]) - 1; /* $ */
 					src += namelen;
@@ -137,7 +430,7 @@ static char *expand_variables(const char *orig, const char *var_names[], const c
 		if (c == '$') {
 			int i;
 			for (i = 0; var_names[i]; i++) {
-				int namelen = strlen(var_names[i]);
+				size_t namelen = strlen(var_names[i]);
 				if (strncmp(var_names[i], src+1, namelen) == 0) {
 					dst = stpcpy(dst, var_values[i]);
 					--dst;
@@ -796,6 +1089,23 @@ static char *md5hash(const char *instname, struct instance_data *idata)
 }
 
 #ifdef WITH_SELINUX
+static char *secure_getfilecon(pam_handle_t *pamh, const char *dir)
+{
+	char *ctx = NULL;
+	int dfd = secure_opendir(dir, SECURE_OPENDIR_FULL_FD, 0, NULL);
+	if (dfd < 0) {
+		pam_syslog(pamh, LOG_ERR, "Error getting fd to %s: %m", dir);
+		return NULL;
+	}
+	if (fgetfilecon(dfd, &ctx) < 0)
+		ctx = NULL;
+	if (ctx == NULL)
+		pam_syslog(pamh, LOG_ERR,
+			   "Error getting poly dir context for %s: %m", dir);
+	close(dfd);
+	return ctx;
+}
+
 static int form_context(const struct polydir_s *polyptr,
 		char **i_context, char **origcon,
 		struct instance_data *idata)
@@ -807,12 +1117,9 @@ static int form_context(const struct polydir_s *polyptr,
 	/*
 	 * Get the security context of the directory to polyinstantiate.
 	 */
-	rc = getfilecon(polyptr->dir, origcon);
-	if (rc < 0 || *origcon == NULL) {
-		pam_syslog(idata->pamh, LOG_ERR,
-				"Error getting poly dir context, %m");
+	*origcon = secure_getfilecon(idata->pamh, polyptr->dir);
+	if (*origcon == NULL)
 		return PAM_SESSION_ERR;
-	}
 
 	if (polyptr->method == USER) return PAM_SUCCESS;
 
@@ -914,23 +1221,47 @@ static int form_context(const struct polydir_s *polyptr,
  * original directory to polyinstantiate and the polyinstantiated instance
  * directory.
  */
+
+/*
+ * From the instance differentiation string, set in the polyptr structure:
+ * - the absolute path to the instance dir,
+ * - the absolute path to the previous dir (parent),
+ * - the instance name (may be different than the instance differentiation string)
+ */
+static int set_polydir_paths(struct polydir_s *polyptr, const char *inst_differentiation)
+{
+	char *tmp;
+
+	if (pam_sprintf(polyptr->instance_absolute, "%s%s",
+	                polyptr->instance_prefix, inst_differentiation) < 0)
+		return -1;
+
+	polyptr->instname = strrchr(polyptr->instance_absolute, '/') + 1;
+
+	if (pam_sprintf(polyptr->instance_parent, "%s", polyptr->instance_absolute) < 0)
+		return -1;
+
+	tmp = strrchr(polyptr->instance_parent, '/') + 1;
+	*tmp = '\0';
+
+	return 0;
+}
+
 #ifdef WITH_SELINUX
-static int poly_name(const struct polydir_s *polyptr, char **i_name,
-	char **i_context, char **origcon,
-        struct instance_data *idata)
+static int poly_name(struct polydir_s *polyptr, char **i_context,
+        char **origcon, struct instance_data *idata)
 #else
-static int poly_name(const struct polydir_s *polyptr, char **i_name,
-	struct instance_data *idata)
+static int poly_name(struct polydir_s *polyptr, struct instance_data *idata)
 #endif
 {
     int rc;
+    char *inst_differentiation = NULL;
     char *hash = NULL;
     enum polymethod pm;
 #ifdef WITH_SELINUX
     char *rawcon = NULL;
 #endif
 
-    *i_name = NULL;
 #ifdef WITH_SELINUX
     *i_context = NULL;
     *origcon = NULL;
@@ -964,10 +1295,8 @@ static int poly_name(const struct polydir_s *polyptr, char **i_name,
 
     switch (pm) {
         case USER:
-	    if (asprintf(i_name, "%s", idata->user) < 0) {
-		*i_name = NULL;
+	    if ((inst_differentiation = strdup(idata->user)) == NULL)
 		goto fail;
-	    }
 	    break;
 
 #ifdef WITH_SELINUX
@@ -977,26 +1306,25 @@ static int poly_name(const struct polydir_s *polyptr, char **i_name,
 		pam_syslog(idata->pamh, LOG_ERR, "Error translating directory context");
 		goto fail;
 	    }
-	    if (polyptr->flags & POLYDIR_SHARED) {
-		if (asprintf(i_name, "%s", rawcon) < 0) {
-			*i_name = NULL;
-			goto fail;
-		}
-	    } else {
-		if (asprintf(i_name, "%s_%s", rawcon, idata->user) < 0) {
-			*i_name = NULL;
-			goto fail;
-		}
-	    }
+	    if (polyptr->flags & POLYDIR_SHARED)
+		inst_differentiation = strdup(rawcon);
+	    else
+		inst_differentiation = pam_asprintf("%s_%s", rawcon, idata->user);
+	    if (inst_differentiation == NULL)
+		goto fail;
 	    break;
 
 #endif /* WITH_SELINUX */
 
 	case TMPDIR:
+	    if ((inst_differentiation = strdup("XXXXXX")) == NULL)
+		goto fail;
+	    goto success;
+
 	case TMPFS:
-	    if ((*i_name=strdup("")) == NULL)
+	    if ((inst_differentiation=strdup("")) == NULL)
 		goto fail;
-	    return PAM_SUCCESS;
+	    goto success;
 
 	default:
 	    if (idata->flags & PAMNS_DEBUG)
@@ -1005,31 +1333,37 @@ static int poly_name(const struct polydir_s *polyptr, char **i_name,
     }
 
     if (idata->flags & PAMNS_DEBUG)
-        pam_syslog(idata->pamh, LOG_DEBUG, "poly_name %s", *i_name);
+        pam_syslog(idata->pamh, LOG_DEBUG, "poly_name %s", inst_differentiation);
 
-    if ((idata->flags & PAMNS_GEN_HASH) || strlen(*i_name) > NAMESPACE_MAX_DIR_LEN) {
-        hash = md5hash(*i_name, idata);
+    if ((idata->flags & PAMNS_GEN_HASH) || strlen(inst_differentiation) > NAMESPACE_MAX_DIR_LEN) {
+        hash = md5hash(inst_differentiation, idata);
         if (hash == NULL) {
 	    goto fail;
         }
         if (idata->flags & PAMNS_GEN_HASH) {
-	    free(*i_name);
-	    *i_name = hash;
+	    free(inst_differentiation);
+	    inst_differentiation = hash;
 	    hash = NULL;
         } else {
-	    char *newname;
-	    if (asprintf(&newname, "%.*s_%s", NAMESPACE_MAX_DIR_LEN-1-(int)strlen(hash),
-		*i_name, hash) < 0) {
+	    char *newname =
+		pam_asprintf("%.*s_%s",
+			     NAMESPACE_MAX_DIR_LEN - 1 - (int)strlen(hash),
+			     inst_differentiation, hash);
+	    if (newname == NULL)
 		goto fail;
-	    }
-	    free(*i_name);
-	    *i_name = newname;
+	    free(inst_differentiation);
+	    inst_differentiation = newname;
         }
     }
-    rc = PAM_SUCCESS;
 
+success:
+    if (set_polydir_paths(polyptr, inst_differentiation) == -1)
+        goto fail;
+
+    rc = PAM_SUCCESS;
 fail:
     free(hash);
+    free(inst_differentiation);
 #ifdef WITH_SELINUX
     freecon(rawcon);
 #endif
@@ -1040,190 +1374,117 @@ fail:
 	freecon(*origcon);
 	*origcon = NULL;
 #endif
-	free(*i_name);
-	*i_name = NULL;
     }
     return rc;
 }
 
-static int protect_mount(int dfd, const char *path, struct instance_data *idata)
+static int check_inst_parent(int dfd, struct instance_data *idata)
 {
-	struct protect_dir_s *dir = idata->protect_dirs;
-	char tmpbuf[64];
-
-	while (dir != NULL) {
-		if (strcmp(path, dir->dir) == 0) {
-			return 0;
-		}
-		dir = dir->next;
-	}
-
-	dir = calloc(1, sizeof(*dir));
-
-	if (dir == NULL) {
-		return -1;
-	}
-
-	dir->dir = strdup(path);
+	struct stat instpbuf;
 
-	if (dir->dir == NULL) {
-		free(dir);
-		return -1;
-	}
+	/*
+	 * Stat the instance parent directory to make sure it's writable by
+	 * root only (unless the admin explicitly instructs to ignore the
+	 * instance parent mode by the "ignore_instance_parent_mode" argument).
+	 */
 
-	snprintf(tmpbuf, sizeof(tmpbuf), "/proc/self/fd/%d", dfd);
+	if (idata->flags & PAMNS_IGN_INST_PARENT_MODE)
+		return PAM_SUCCESS;
 
-	if (idata->flags & PAMNS_DEBUG) {
-		pam_syslog(idata->pamh, LOG_INFO,
-			"Protect mount of %s over itself", path);
+	if (fstat(dfd, &instpbuf) < 0) {
+		pam_syslog(idata->pamh, LOG_ERR,
+			"Error accessing instance parent, %m");
+		return PAM_SESSION_ERR;
 	}
 
-	if (mount(tmpbuf, tmpbuf, NULL, MS_BIND, NULL) != 0) {
-		int save_errno = errno;
+	if ((instpbuf.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) || instpbuf.st_uid != 0) {
 		pam_syslog(idata->pamh, LOG_ERR,
-			"Protect mount of %s failed: %m", tmpbuf);
-		free(dir->dir);
-		free(dir);
-		errno = save_errno;
-		return -1;
+			"Mode of inst parent not 000 or owner not root");
+		return PAM_SESSION_ERR;
 	}
 
-	dir->next = idata->protect_dirs;
-	idata->protect_dirs = dir;
-
-	return 0;
+	return PAM_SUCCESS;
 }
 
-static int protect_dir(const char *path, mode_t mode, int do_mkdir,
-	struct instance_data *idata)
+/*
+ * Check for a given absolute path that all segments except the last one are:
+ * 1. a directory owned by root and not writable by group or others
+ * 2. a symlink owned by root and referencing a directory respecting 1.
+ * Returns 0 if safe, -1 is unsafe.
+ * If the path is not accessible (does not exist, hidden under a mount...),
+ * returns -1 (unsafe).
+ */
+static int check_safe_path(const char *path, struct instance_data *idata)
 {
-	char *p = strdup(path);
-	char *d;
-	char *dir = p;
-	int dfd = AT_FDCWD;
-	int dfd_next;
-	int save_errno;
-	int flags = O_RDONLY | O_DIRECTORY;
-	int rv = -1;
-	struct stat st;
+    char *p = strdup(path);
+    char *d;
+    char *dir = p;
+    struct stat st;
 
-	if (p == NULL) {
-		goto error;
-	}
-
-	if (*dir == '/') {
-		dfd = open("/", flags);
-		if (dfd == -1) {
-			goto error;
-		}
-		dir++;	/* assume / is safe */
-	}
-
-	while ((d=strchr(dir, '/')) != NULL) {
-		*d = '\0';
-		dfd_next = openat(dfd, dir, flags);
-		if (dfd_next == -1) {
-			goto error;
-		}
-
-		if (dfd != AT_FDCWD)
-			close(dfd);
-		dfd = dfd_next;
-
-		if (fstat(dfd, &st) != 0) {
-			goto error;
-		}
+    if (p == NULL)
+        return -1;
 
-		if (flags & O_NOFOLLOW) {
-			/* we are inside user-owned dir - protect */
-			if (protect_mount(dfd, p, idata) == -1)
-				goto error;
-		} else if (st.st_uid != 0 || st.st_gid != 0 ||
-			(st.st_mode & S_IWOTH)) {
-			/* do not follow symlinks on subdirectories */
-			flags |= O_NOFOLLOW;
-		}
+    /* Check path is absolute */
+    if (p[0] != '/')
+        goto error;
 
-		*d = '/';
-		dir = d + 1;
-	}
+    strip_trailing_slashes(p);
 
-	rv = openat(dfd, dir, flags);
+    /* Last segment of the path may be owned by the user */
+    if ((d = strrchr(dir, '/')) != NULL)
+        *d = '\0';
 
-	if (rv == -1) {
-		if (!do_mkdir || mkdirat(dfd, dir, mode) != 0) {
-			goto error;
-		}
-		rv = openat(dfd, dir, flags);
-	}
+    while ((d=strrchr(dir, '/')) != NULL) {
 
-	if (flags & O_NOFOLLOW) {
-		/* we are inside user-owned dir - protect */
-		if (protect_mount(rv, p, idata) == -1) {
-			save_errno = errno;
-			close(rv);
-			rv = -1;
-			errno = save_errno;
-		}
-	}
+        /* Do not follow symlinks */
+        if (lstat(dir, &st) != 0)
+            goto error;
 
-error:
-	save_errno = errno;
-	free(p);
-	if (dfd != AT_FDCWD && dfd >= 0)
-		close(dfd);
-	errno = save_errno;
+        if (S_ISLNK(st.st_mode)) {
+            if (st.st_uid != 0) {
+                if (idata->flags & PAMNS_DEBUG)
+                    pam_syslog(idata->pamh, LOG_DEBUG,
+                            "Path deemed unsafe: Symlink %s should be owned by root", dir);
+                goto error;
+            }
 
-	return rv;
-}
+            /* Follow symlinks */
+            if (stat(dir, &st) != 0)
+                goto error;
+        }
 
-static int check_inst_parent(char *ipath, struct instance_data *idata)
-{
-	struct stat instpbuf;
-	char *inst_parent, *trailing_slash;
-	int dfd;
-	/*
-	 * stat the instance parent path to make sure it exists
-	 * and is a directory. Check that its mode is 000 (unless the
-	 * admin explicitly instructs to ignore the instance parent
-	 * mode by the "ignore_instance_parent_mode" argument).
-	 */
-	inst_parent = (char *) malloc(strlen(ipath)+1);
-	if (!inst_parent) {
-		pam_syslog(idata->pamh, LOG_CRIT, "Error allocating pathname string");
-		return PAM_SESSION_ERR;
-	}
+        if (!S_ISDIR(st.st_mode)) {
+                if (idata->flags & PAMNS_DEBUG)
+                    pam_syslog(idata->pamh, LOG_DEBUG,
+                        "Path deemed unsafe: %s is expected to be a directory", dir);
+            goto error;
+        }
 
-	strcpy(inst_parent, ipath);
-	trailing_slash = strrchr(inst_parent, '/');
-	if (trailing_slash)
-		*trailing_slash = '\0';
+        if (st.st_uid != 0 ||
+            ((st.st_mode & (S_IWGRP|S_IWOTH)) && !(st.st_mode & S_ISVTX))) {
+                if (idata->flags & PAMNS_DEBUG)
+                    pam_syslog(idata->pamh, LOG_DEBUG,
+                        "Path deemed unsafe: %s should be owned by root, and not be writable by group or others", dir);
+            goto error;
+        }
 
-	dfd = protect_dir(inst_parent, 0, 1, idata);
+        *d = '\0';
+    }
 
-	if (dfd == -1 || fstat(dfd, &instpbuf) < 0) {
-		pam_syslog(idata->pamh, LOG_ERR,
-			"Error creating or accessing instance parent %s, %m", inst_parent);
-		if (dfd != -1)
-			close(dfd);
-		free(inst_parent);
-		return PAM_SESSION_ERR;
-	}
+    free(p);
+    return 0;
 
-	if ((idata->flags & PAMNS_IGN_INST_PARENT_MODE) == 0) {
-		if ((instpbuf.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) || instpbuf.st_uid != 0) {
-			pam_syslog(idata->pamh, LOG_ERR, "Mode of inst parent %s not 000 or owner not root",
-					inst_parent);
-			close(dfd);
-			free(inst_parent);
-			return PAM_SESSION_ERR;
-		}
-	}
-	close(dfd);
-	free(inst_parent);
-	return PAM_SUCCESS;
+error:
+    free(p);
+    return -1;
 }
 
+/*
+ * From the instance differentiation string, set in the polyptr structure:
+ * - the absolute path to the instance dir,
+ * - the absolute path to the previous dir (parent),
+ * - the instance name (may be different than the instance differentiation string)
+ */
 /*
 * Check to see if there is a namespace initialization script in
 * the /etc/security directory. If such a script exists
@@ -1270,9 +1531,15 @@ static int inst_init(const struct polydir_s *polyptr, const char *ipath,
 					/* ignore failures, they don't matter */
 				}
 
-				if (execle(init_script, init_script,
-					polyptr->dir, ipath, newdir?"1":"0", idata->user, NULL, envp) < 0)
-					_exit(1);
+				close_fds_pre_exec(idata);
+
+				execle(init_script, init_script,
+				       polyptr->dir, ipath,
+				       newdir ? "1":"0", idata->user,
+				       (check_safe_path(polyptr->dir, idata) == -1) ? "0":"1",
+				       (check_safe_path(ipath, idata) == -1) ? "0":"1",
+				       NULL, envp);
+				_exit(1);
 			} else if (pid > 0) {
 				while (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&
 						(errno == EINTR));
@@ -1347,11 +1614,16 @@ static int create_polydir(struct polydir_s *polyptr,
     }
 #endif
 
-    rc = protect_dir(dir, mode, 1, idata);
+    rc = secure_opendir(dir,
+            SECURE_OPENDIR_PROTECT | SECURE_OPENDIR_MKDIR | SECURE_OPENDIR_FULL_FD,
+            mode, idata);
     if (rc == -1) {
             pam_syslog(idata->pamh, LOG_ERR,
                        "Error creating directory %s: %m", dir);
-            return PAM_SESSION_ERR;
+#ifdef WITH_SELINUX
+            freecon(oldcon_raw);
+#endif
+            return -1;
     }
 
 #ifdef WITH_SELINUX
@@ -1372,9 +1644,9 @@ static int create_polydir(struct polydir_s *polyptr,
 		pam_syslog(idata->pamh, LOG_ERR,
 			   "Error changing mode of directory %s: %m", dir);
                 close(rc);
-                umount(dir); /* undo the eventual protection bind mount */
-		rmdir(dir);
-		return PAM_SESSION_ERR;
+		secure_umount(dir); /* undo the eventual protection bind mount */
+		secure_try_rmdir(dir);
+		return -1;
 	}
     }
 
@@ -1392,41 +1664,40 @@ static int create_polydir(struct polydir_s *polyptr,
         pam_syslog(idata->pamh, LOG_ERR,
                    "Unable to change owner on directory %s: %m", dir);
         close(rc);
-        umount(dir); /* undo the eventual protection bind mount */
-	rmdir(dir);
-	return PAM_SESSION_ERR;
+	secure_umount(dir); /* undo the eventual protection bind mount */
+	secure_try_rmdir(dir);
+	return -1;
     }
 
-    close(rc);
-
     if (idata->flags & PAMNS_DEBUG)
 	pam_syslog(idata->pamh, LOG_DEBUG,
 	           "Polydir owner %u group %u", uid, gid);
 
-    return PAM_SUCCESS;
+    return rc;
 }
 
 /*
  * Create polyinstantiated instance directory (ipath).
  */
+/*
+ * Create polyinstantiated instance directory.
+ * To protect against races, changes are done on a fd to the parent of the
+ * instance directory (dfd_iparent) and a relative path (polyptr->instname).
+ * The absolute path (polyptr->instance_absolute) is only updated when creating
+ * a tmpdir and used for logging purposes.
+ */
 #ifdef WITH_SELINUX
-static int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *statbuf,
-        const char *icontext, const char *ocontext,
-	struct instance_data *idata)
+static int create_instance(struct polydir_s *polyptr, int dfd_iparent,
+        struct stat *statbuf, const char *icontext, const char *ocontext,
+        struct instance_data *idata)
 #else
-static int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *statbuf,
-	struct instance_data *idata)
+static int create_instance(struct polydir_s *polyptr, int dfd_iparent,
+        struct stat *statbuf, struct instance_data *idata)
 #endif
 {
     struct stat newstatbuf;
     int fd;
 
-    /*
-     * Check to make sure instance parent is valid.
-     */
-    if (check_inst_parent(ipath, idata))
-	return PAM_SESSION_ERR;
-
     /*
      * Create instance directory and set its security context to the context
      * returned by the security policy. Set its mode and ownership
@@ -1435,29 +1706,39 @@ static int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *
      */
 
     if (polyptr->method == TMPDIR) {
-	if (mkdtemp(polyptr->instance_prefix) == NULL) {
-            pam_syslog(idata->pamh, LOG_ERR, "Error creating temporary instance %s, %m",
-			polyptr->instance_prefix);
-	    polyptr->method = NONE; /* do not clean up! */
-	    return PAM_SESSION_ERR;
-	}
-	/* copy the actual directory name to ipath */
-	strcpy(ipath, polyptr->instance_prefix);
-    } else if (mkdir(ipath, S_IRUSR) < 0) {
+        char s_path[PATH_MAX];
+        /*
+         * Create the template for mkdtemp() as a magic link based on
+         * our existing fd to avoid symlink attacks and races.
+         */
+        if (pam_sprintf(s_path, "/proc/self/fd/%d/%s", dfd_iparent, polyptr->instname) < 0
+            || mkdtemp(s_path) == NULL) {
+            pam_syslog(idata->pamh, LOG_ERR,
+                       "Error creating temporary instance dir %s, %m",
+                       polyptr->instance_absolute);
+            polyptr->method = NONE; /* do not clean up! */
+            return PAM_SESSION_ERR;
+        }
+
+        /* Copy the actual directory name to polyptr->instname */
+        strcpy(polyptr->instname, base_name(s_path));
+    } else if (mkdirat(dfd_iparent, polyptr->instname, S_IRUSR) < 0) {
         if (errno == EEXIST)
             return PAM_IGNORE;
         else {
             pam_syslog(idata->pamh, LOG_ERR, "Error creating %s, %m",
-			ipath);
+                       polyptr->instance_absolute);
             return PAM_SESSION_ERR;
         }
     }
 
-    /* Open a descriptor to it to prevent races */
-    fd = open(ipath, O_DIRECTORY | O_RDONLY);
+    /* Open a descriptor to prevent races, based on our existing fd. */
+    fd = openat(dfd_iparent, polyptr->instname,
+            O_RDONLY | O_DIRECTORY | O_NOFOLLOW | O_CLOEXEC);
     if (fd < 0) {
-	pam_syslog(idata->pamh, LOG_ERR, "Error opening %s, %m", ipath);
-	rmdir(ipath);
+	pam_syslog(idata->pamh, LOG_ERR, "Error opening %s, %m",
+                polyptr->instance_absolute);
+	unlinkat(dfd_iparent, polyptr->instname, AT_REMOVEDIR);
 	return PAM_SESSION_ERR;
     }
 #ifdef WITH_SELINUX
@@ -1467,17 +1748,19 @@ static int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *
         if (icontext) {
             if (fsetfilecon(fd, icontext) < 0) {
                 pam_syslog(idata->pamh, LOG_ERR,
-			"Error setting context of %s to %s", ipath, icontext);
+			"Error setting context of %s to %s",
+                        polyptr->instance_absolute, icontext);
                 close(fd);
-		rmdir(ipath);
+                unlinkat(dfd_iparent, polyptr->instname, AT_REMOVEDIR);
                 return PAM_SESSION_ERR;
             }
         } else {
             if (fsetfilecon(fd, ocontext) < 0) {
                 pam_syslog(idata->pamh, LOG_ERR,
-			"Error setting context of %s to %s", ipath, ocontext);
+			"Error setting context of %s to %s",
+                        polyptr->instance_absolute, ocontext);
 		close(fd);
-		rmdir(ipath);
+                unlinkat(dfd_iparent, polyptr->instname, AT_REMOVEDIR);
                 return PAM_SESSION_ERR;
             }
         }
@@ -1485,9 +1768,9 @@ static int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *
 #endif
     if (fstat(fd, &newstatbuf) < 0) {
         pam_syslog(idata->pamh, LOG_ERR, "Error stating %s, %m",
-		ipath);
+		polyptr->instance_absolute);
 	close(fd);
-	rmdir(ipath);
+        unlinkat(dfd_iparent, polyptr->instname, AT_REMOVEDIR);
         return PAM_SESSION_ERR;
     }
     if (newstatbuf.st_uid != statbuf->st_uid ||
@@ -1495,17 +1778,17 @@ static int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *
         if (fchown(fd, statbuf->st_uid, statbuf->st_gid) < 0) {
             pam_syslog(idata->pamh, LOG_ERR,
 			"Error changing owner for %s, %m",
-			ipath);
+			polyptr->instance_absolute);
 	    close(fd);
-	    rmdir(ipath);
+            unlinkat(dfd_iparent, polyptr->instname, AT_REMOVEDIR);
             return PAM_SESSION_ERR;
         }
     }
     if (fchmod(fd, statbuf->st_mode & 07777) < 0) {
         pam_syslog(idata->pamh, LOG_ERR, "Error changing mode for %s, %m",
-			ipath);
+			polyptr->instance_absolute);
 	close(fd);
-	rmdir(ipath);
+        unlinkat(dfd_iparent, polyptr->instname, AT_REMOVEDIR);
         return PAM_SESSION_ERR;
     }
     close(fd);
@@ -1524,9 +1807,12 @@ static int ns_setup(struct polydir_s *polyptr,
 	struct instance_data *idata)
 {
     int retval;
+    int dfd_iparent = -1;
+    int dfd_ipath = -1;
+    int dfd_pptrdir = -1;
     int newdir = 1;
-    char *inst_dir = NULL;
-    char *instname = NULL;
+    char s_ipath[MAGIC_LNK_FD_SIZE];
+    char s_pptrdir[MAGIC_LNK_FD_SIZE];
     struct stat statbuf;
 #ifdef WITH_SELINUX
     char *instcontext = NULL, *origcontext = NULL;
@@ -1536,39 +1822,48 @@ static int ns_setup(struct polydir_s *polyptr,
         pam_syslog(idata->pamh, LOG_DEBUG,
                "Set namespace for directory %s", polyptr->dir);
 
-    retval = protect_dir(polyptr->dir, 0, 0, idata);
-
-    if (retval < 0 && errno != ENOENT) {
-	pam_syslog(idata->pamh, LOG_ERR, "Polydir %s access error: %m",
-		polyptr->dir);
-	return PAM_SESSION_ERR;
-    }
+    dfd_pptrdir = secure_opendir(polyptr->dir, SECURE_OPENDIR_PROTECT, 0, idata);
 
-    if (retval < 0) {
-	if ((polyptr->flags & POLYDIR_CREATE) &&
-		create_polydir(polyptr, idata) != PAM_SUCCESS)
-		return PAM_SESSION_ERR;
-    } else {
-	close(retval);
+    if (dfd_pptrdir < 0) {
+        if (errno != ENOENT || !(polyptr->flags & POLYDIR_CREATE)) {
+            pam_syslog(idata->pamh, LOG_ERR, "Polydir %s access error: %m",
+                    polyptr->dir);
+            return PAM_SESSION_ERR;
+        }
+        dfd_pptrdir = create_polydir(polyptr, idata);
+        if (dfd_pptrdir < 0)
+            return PAM_SESSION_ERR;
     }
 
     if (polyptr->method == TMPFS) {
-	if (mount("tmpfs", polyptr->dir, "tmpfs", polyptr->mount_flags, polyptr->mount_opts) < 0) {
-	    pam_syslog(idata->pamh, LOG_ERR, "Error mounting tmpfs on %s, %m",
-		polyptr->dir);
-            return PAM_SESSION_ERR;
-	}
+        /*
+         * There is no function mount() that operate on a fd, so instead, we
+         * get the magic link corresponding to the fd and give it to mount().
+         * This protects against potential races exploitable by an unpriv user.
+         */
+        if (pam_sprintf(s_pptrdir, "/proc/self/fd/%d", dfd_pptrdir) < 0) {
+            pam_syslog(idata->pamh, LOG_ERR, "Error pam_sprintf s_pptrdir");
+            goto error_out;
+        }
+
+        if (mount("tmpfs", s_pptrdir, "tmpfs", polyptr->mount_flags, polyptr->mount_opts) < 0) {
+            pam_syslog(idata->pamh, LOG_ERR, "Error mounting tmpfs on %s, %m",
+                       polyptr->dir);
+            goto error_out;
+        }
 
-	if (polyptr->flags & POLYDIR_NOINIT)
-	    return PAM_SUCCESS;
+        if (polyptr->flags & POLYDIR_NOINIT) {
+            retval = PAM_SUCCESS;
+            goto cleanup;
+        }
 
-	return inst_init(polyptr, "tmpfs", idata, 1);
+        retval = inst_init(polyptr, "tmpfs", idata, 1);
+        goto cleanup;
     }
 
-    if (stat(polyptr->dir, &statbuf) < 0) {
-	pam_syslog(idata->pamh, LOG_ERR, "Error stating %s: %m",
-		polyptr->dir);
-        return PAM_SESSION_ERR;
+    if (fstat(dfd_pptrdir, &statbuf) < 0) {
+        pam_syslog(idata->pamh, LOG_ERR, "Error stating %s: %m", polyptr->dir);
+        goto error_out;
     }
 
     /*
@@ -1577,15 +1872,16 @@ static int ns_setup(struct polydir_s *polyptr,
      * security policy.
      */
 #ifdef WITH_SELINUX
-    retval = poly_name(polyptr, &instname, &instcontext,
-			&origcontext, idata);
+    retval = poly_name(polyptr, &instcontext, &origcontext, idata);
 #else
-    retval = poly_name(polyptr, &instname, idata);
+    retval = poly_name(polyptr, idata);
 #endif
 
     if (retval != PAM_SUCCESS) {
-	if (retval != PAM_IGNORE)
+	if (retval != PAM_IGNORE) {
 		pam_syslog(idata->pamh, LOG_ERR, "Error getting instance name");
+                goto error_out;
+        }
         goto cleanup;
     } else {
 #ifdef WITH_SELINUX
@@ -1596,22 +1892,33 @@ static int ns_setup(struct polydir_s *polyptr,
 #endif
     }
 
-    if (asprintf(&inst_dir, "%s%s", polyptr->instance_prefix, instname) < 0)
-	goto error_out;
-
-    if (idata->flags & PAMNS_DEBUG)
-        pam_syslog(idata->pamh, LOG_DEBUG, "instance_dir %s",
-		inst_dir);
+    /*
+     * Gets a fd in a secure manner (we may be operating on a path under
+     * user control), and check it's compliant.
+     * Then, we should *always* operate on *this* fd and a relative path
+     * to be protected against race conditions.
+     */
+    dfd_iparent = secure_opendir(polyptr->instance_parent,
+            SECURE_OPENDIR_PROTECT | SECURE_OPENDIR_MKDIR, 0, idata);
+    if (dfd_iparent == -1) {
+	pam_syslog(idata->pamh, LOG_ERR,
+                "polyptr->instance_parent %s access error",
+                polyptr->instance_parent);
+        goto error_out;
+    }
+    if (check_inst_parent(dfd_iparent, idata)) {
+        goto error_out;
+    }
 
     /*
      * Create instance directory with appropriate security
      * contexts, owner, group and mode bits.
      */
 #ifdef WITH_SELINUX
-    retval = create_instance(polyptr, inst_dir, &statbuf, instcontext,
-			 origcontext, idata);
+    retval = create_instance(polyptr, dfd_iparent, &statbuf, instcontext,
+                             origcontext, idata);
 #else
-    retval = create_instance(polyptr, inst_dir, &statbuf, idata);
+    retval = create_instance(polyptr, dfd_iparent, &statbuf, idata);
 #endif
 
     if (retval == PAM_IGNORE) {
@@ -1623,19 +1930,48 @@ static int ns_setup(struct polydir_s *polyptr,
         goto error_out;
     }
 
+    /*
+     * Instead of getting a new secure fd, we reuse the fd opened on directory
+     * polyptr->instance_parent to ensure we are working on the same dir as
+     * previously, and thus ensure that previous checks (e.g. check_inst_parent())
+     * are still relevant.
+     */
+    dfd_ipath = openat(dfd_iparent, polyptr->instname,
+            O_PATH | O_DIRECTORY | O_NOFOLLOW | O_CLOEXEC);
+    if (dfd_ipath == -1) {
+        pam_syslog(idata->pamh, LOG_ERR, "Error openat on %s, %m",
+                polyptr->instname);
+        goto error_out;
+    }
+
+    if (pam_sprintf(s_ipath, "/proc/self/fd/%d", dfd_ipath) < 0) {
+        pam_syslog(idata->pamh, LOG_ERR, "Error pam_sprintf s_ipath");
+        goto error_out;
+    }
+
+    if (pam_sprintf(s_pptrdir, "/proc/self/fd/%d", dfd_pptrdir) < 0) {
+        pam_syslog(idata->pamh, LOG_ERR, "Error pam_sprintf s_pptrdir");
+        goto error_out;
+    }
+
     /*
      * Bind mount instance directory on top of the polyinstantiated
      * directory to provide an instance of polyinstantiated directory
      * based on polyinstantiated method.
+     *
+     * Operates on magic links created from two fd obtained securely
+     * to protect against race conditions and symlink attacks. Indeed,
+     * the source and destination can be in a user controled path.
      */
-    if (mount(inst_dir, polyptr->dir, NULL, MS_BIND, NULL) < 0) {
-        pam_syslog(idata->pamh, LOG_ERR, "Error mounting %s on %s, %m",
-                   inst_dir, polyptr->dir);
+    if(mount(s_ipath, s_pptrdir, NULL, MS_BIND, NULL) < 0) {
+        pam_syslog(idata->pamh, LOG_ERR,
+                "Error mounting %s on %s (%s on %s), %m",
+                   s_ipath, s_pptrdir, polyptr->instance_absolute, polyptr->dir);
         goto error_out;
     }
 
     if (!(polyptr->flags & POLYDIR_NOINIT))
-	retval = inst_init(polyptr, inst_dir, idata, newdir);
+	retval = inst_init(polyptr, polyptr->instance_absolute, idata, newdir);
 
     goto cleanup;
 
@@ -1647,8 +1983,12 @@ error_out:
     retval = PAM_SESSION_ERR;
 
 cleanup:
-    free(inst_dir);
-    free(instname);
+    if (dfd_iparent != -1)
+        close(dfd_iparent);
+    if (dfd_ipath != -1)
+        close(dfd_ipath);
+    if (dfd_pptrdir != -1)
+        close(dfd_pptrdir);
 #ifdef WITH_SELINUX
     freecon(instcontext);
     freecon(origcontext);
diff --git a/modules/pam_namespace/pam_namespace.h b/modules/pam_namespace/pam_namespace.h
index b51f2841..94cb7d86 100644
--- a/modules/pam_namespace/pam_namespace.h
+++ b/modules/pam_namespace/pam_namespace.h
@@ -124,6 +124,13 @@
 #define NAMESPACE_POLYDIR_DATA "pam_namespace:polydir_data"
 #define NAMESPACE_PROTECT_DATA "pam_namespace:protect_data"
 
+/*
+ * Operation mode for function secure_opendir()
+ */
+#define SECURE_OPENDIR_PROTECT     0x00000001
+#define SECURE_OPENDIR_MKDIR       0x00000002
+#define SECURE_OPENDIR_FULL_FD     0x00000004
+
 /*
  * Polyinstantiation method options, based on user, security context
  * or both
@@ -161,6 +168,9 @@ struct polydir_s {
     char dir[PATH_MAX];    	       	/* directory to polyinstantiate */
     char rdir[PATH_MAX];    	       	/* directory to unmount (based on RUSER) */
     char instance_prefix[PATH_MAX];	/* prefix for instance dir path name */
+    char instance_absolute[PATH_MAX];	/* absolute path to the instance dir (instance_parent + instname) */
+    char instance_parent[PATH_MAX];	/* parent dir of the instance dir */
+    char *instname;			/* last segment of the path to the instance dir */
     enum polymethod method;		/* method used to polyinstantiate */
     unsigned int num_uids;		/* number of override uids */
     uid_t *uid;				/* list of override uids */
-- 
2.50.0

From 88cf301867488fc19f49467e86b56bb390acf798 Mon Sep 17 00:00:00 2001
From: Amal C S <amal4cs@gmail.com>
Date: Wed, 16 Jul 2025 11:17:43 +0530
Subject: [PATCH] Patch CVE-2024-10041

---
 modules/pam_unix/pam_unix_acct.c | 17 +++++++++--------
 modules/pam_unix/passverify.c    | 21 +++++++++++----------
 modules/pam_unix/support.c       | 14 +++++++-------
 3 files changed, 27 insertions(+), 25 deletions(-)

diff --git a/modules/pam_unix/pam_unix_acct.c b/modules/pam_unix/pam_unix_acct.c
index 8f5ed3e0..7ffcb9e3 100644
--- a/modules/pam_unix/pam_unix_acct.c
+++ b/modules/pam_unix/pam_unix_acct.c
@@ -110,14 +110,15 @@ int _unix_run_verify_binary(pam_handle_t *pamh, unsigned long long ctrl,
       _exit(PAM_AUTHINFO_UNAVAIL);
     }
 
-    if (geteuid() == 0) {
-      /* must set the real uid to 0 so the helper will not error
-         out if pam is called from setuid binary (su, sudo...) */
-      if (setuid(0) == -1) {
-          pam_syslog(pamh, LOG_ERR, "setuid failed: %m");
-          printf("-1\n");
-          fflush(stdout);
-          _exit(PAM_AUTHINFO_UNAVAIL);
+    /* must set the real uid to 0 so the helper will not error
+       out if pam is called from setuid binary (su, sudo...) */
+    if (setuid(0) == -1) {
+      uid_t euid = geteuid();
+      pam_syslog(pamh, euid == 0 ? LOG_ERR : LOG_DEBUG, "setuid failed: %m");
+      if (euid == 0) {
+	printf("-1\n");
+	fflush(stdout);
+	_exit(PAM_AUTHINFO_UNAVAIL);
       }
     }
 
diff --git a/modules/pam_unix/passverify.c b/modules/pam_unix/passverify.c
index f2474a5b..b3005222 100644
--- a/modules/pam_unix/passverify.c
+++ b/modules/pam_unix/passverify.c
@@ -237,20 +237,21 @@ PAMH_ARG_DECL(int get_account_info,
 			return PAM_UNIX_RUN_HELPER;
 #endif
 		} else if (is_pwd_shadowed(*pwd)) {
+#ifdef HELPER_COMPILE
 			/*
-			 * ...and shadow password file entry for this user,
+			 * shadow password file entry for this user,
 			 * if shadowing is enabled
 			 */
-			*spwdent = pam_modutil_getspnam(pamh, name);
-			if (*spwdent == NULL) {
-#ifndef HELPER_COMPILE
-				/* still a chance the user can authenticate */
-				return PAM_UNIX_RUN_HELPER;
-#endif
-				return PAM_AUTHINFO_UNAVAIL;
-			}
-			if ((*spwdent)->sp_pwdp == NULL)
+			*spwdent = getspnam(name);
+			if (*spwdent == NULL || (*spwdent)->sp_pwdp == NULL)
 				return PAM_AUTHINFO_UNAVAIL;
+#else
+			/*
+			 * The helper has to be invoked to deal with
+			 * the shadow password file entry.
+			 */
+			return PAM_UNIX_RUN_HELPER;
+#endif
 		}
 	} else {
 		return PAM_USER_UNKNOWN;
diff --git a/modules/pam_unix/support.c b/modules/pam_unix/support.c
index 27ca7127..fcf79fa2 100644
--- a/modules/pam_unix/support.c
+++ b/modules/pam_unix/support.c
@@ -513,13 +513,13 @@ static int _unix_run_helper_binary(pam_handle_t *pamh, const char *passwd,
 		_exit(PAM_AUTHINFO_UNAVAIL);
 	}
 
-	if (geteuid() == 0) {
-          /* must set the real uid to 0 so the helper will not error
-	     out if pam is called from setuid binary (su, sudo...) */
-	  if (setuid(0) == -1) {
-             D(("setuid failed"));
-	     _exit(PAM_AUTHINFO_UNAVAIL);
-          }
+	/* must set the real uid to 0 so the helper will not error
+	   out if pam is called from setuid binary (su, sudo...) */
+	if (setuid(0) == -1) {
+	   D(("setuid failed"));
+	   if (geteuid() == 0) {
+	      _exit(PAM_AUTHINFO_UNAVAIL);
+	   }
 	}
 
 	/* exec binary helper */
-- 
2.50.1

