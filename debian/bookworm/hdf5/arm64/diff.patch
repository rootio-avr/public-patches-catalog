From 0a7f89d5ad984d49ca64be9c773143eceaf49b77 Mon Sep 17 00:00:00 2001
From: abushwang <31229623+wswsmao@users.noreply.github.com>
Date: Wed, 4 Sep 2024 00:11:07 +0800
Subject: [PATCH] Fix CVE-2022-25942: Add bounds checking to avoid Out-of-bounds Write for gif2h5

Backported to hdf5_1_10_8

This fix adds bounds checking in the Decompress function to prevent
out-of-bounds array access when processing specially-crafted GIF files.
The vulnerability could lead to code execution via buffer overflow.

The fix checks if FreeCode exceeds the array bounds (4096) before
accessing the Prefix and Suffix arrays.

---
 hl/tools/gif2h5/decompress.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/hl/tools/gif2h5/decompress.c b/hl/tools/gif2h5/decompress.c
index e87a60cf7a..62a22922ff 100644
--- a/hl/tools/gif2h5/decompress.c
+++ b/hl/tools/gif2h5/decompress.c
@@ -296,6 +296,10 @@ Decompress(GIFIMAGEDESC *GifImageDesc, GIFHEAD *GifHead)
              * Build the hash table on-the-fly. No table is stored in the
              * file.
              */
+            if (FreeCode >= 4096) {
+                printf("Error: FreeCode out of bounds\n");
+                exit(EXIT_FAILURE);
+            }
             Prefix[FreeCode] = OldCode;
             Suffix[FreeCode] = FinChar;
             OldCode          = InCode;
-- 
2.45.2 From 820e8d8b1df6df0f08a23509696065848e1cda20 Mon Sep 17 00:00:00 2001
Date: Fri, 1 Aug 2025 17:44:19 +0530
Subject: [PATCH] CVE-2024-32606 Fix

---
 tools/lib/h5tools_str.c | 62 ++++++++++++++++++++++-------------------
 1 file changed, 33 insertions(+), 29 deletions(-)

diff --git a/tools/lib/h5tools_str.c b/tools/lib/h5tools_str.c
index 3102d92a88..f8b3ca0569 100644
--- a/tools/lib/h5tools_str.c
+++ b/tools/lib/h5tools_str.c
@@ -1084,36 +1084,40 @@ h5tools_str_sprint(h5tools_str_t *str, const h5tool_format_t *info, hid_t contai
 
                         H5TOOLS_DEBUG("H5T_REFERENCE:H5T_STD_REF_OBJ");
                         obj = H5Rdereference2(container, H5P_DEFAULT, H5R_OBJECT, vp);
-                        H5Oget_info2(obj, &oi, H5O_INFO_BASIC);
-
-                        /* Print object type and close object */
-                        switch (oi.type) {
-                            case H5O_TYPE_GROUP:
-                                h5tools_str_append(str, H5_TOOLS_GROUP);
-                                break;
-
-                            case H5O_TYPE_DATASET:
-                                h5tools_str_append(str, H5_TOOLS_DATASET);
-                                break;
-
-                            case H5O_TYPE_NAMED_DATATYPE:
-                                h5tools_str_append(str, H5_TOOLS_DATATYPE);
-                                break;
-
-                            case H5O_TYPE_UNKNOWN:
-                            case H5O_TYPE_NTYPES:
-                            default:
-                                h5tools_str_append(str, "%u-", (unsigned)oi.type);
-                                break;
-                        } /* end switch */
-                        H5Oclose(obj);
-
-                        /* Print OID */
-                        if (info->obj_hidefileno)
-                            h5tools_str_append(str, info->obj_format, oi.addr);
-                        else
-                            h5tools_str_append(str, info->obj_format, oi.fileno, oi.addr);
+                        if (obj >= 0) {
+                            H5Oget_info2(obj, &oi, H5O_INFO_BASIC);
+
+                            /* Print object type and close object */
+                            switch (oi.type) {
+                                case H5O_TYPE_GROUP:
+                                    h5tools_str_append(str, H5_TOOLS_GROUP);
+                                    break;
+
+                                case H5O_TYPE_DATASET:
+                                    h5tools_str_append(str, H5_TOOLS_DATASET);
+                                    break;
+
+                                case H5O_TYPE_NAMED_DATATYPE:
+                                    h5tools_str_append(str, H5_TOOLS_DATATYPE);
+                                    break;
+
+                                case H5O_TYPE_UNKNOWN:
+                                case H5O_TYPE_NTYPES:
+                                default:
+                                    h5tools_str_append(str, "%u-", (unsigned)oi.type);
+                                    break;
+                            } /* end switch */
+
+                            /* Print OID */
+                            if (info->obj_hidefileno)
+                                h5tools_str_append(str, info->obj_format, oi.addr);
+                            else
+                                h5tools_str_append(str, info->obj_format, oi.fileno, oi.addr);
 
+                            H5Oclose(obj);
+                        } else {
+                            h5tools_str_append(str, "<unknown>");
+                        }
                         h5tools_str_sprint_reference(str, container, vp);
                     } /* end else if (H5Tequal(type, H5T_STD_REF_OBJ)) */
                 }
-- 
2.43.0

From 02f3c0b9441e75ab0a79f7ff7529a5ccc648adbb Mon Sep 17 00:00:00 2001
Date: Tue, 12 Aug 2025 17:41:50 +0530
Subject: [PATCH] Make sure info block for external links has at least 3 bytes
 (#2234) According to the specification, the information block for external
 links contains 1 byte of version/flag information and two 0 terminated
 strings for the object linked to and the full path. Although not very useful,
 the minimum string length for each (with terminating 0) would be one byte.
 Checking this will help to avoid SEGVs triggered by bogus files.

This fixes CVE-2018-16438 / Bug #2233.

Signed-off-by: Egbert Eich <eich@suse.com>
---
 release_docs/RELEASE.txt | 14 ++++++++++++++
 src/H5Olink.c            |  2 ++
 2 files changed, 16 insertions(+)

diff --git a/release_docs/RELEASE.txt b/release_docs/RELEASE.txt
index 589360a..4331860 100644
--- a/release_docs/RELEASE.txt
+++ b/release_docs/RELEASE.txt
@@ -970,3 +970,17 @@ These CVE issues have not yet been addressed and can be avoided by not building
 the gif tool. Disable building the High-Level tools with these options:
     autotools:   --disable-hltools
     cmake:       HDF5_BUILD_HL_TOOLS=OFF
+
+
+Fix CVE-2018-16438 / GHSA-9xmm-cpf8-rgmx
+
+    Make sure info block for external links has at least 3 bytes.
+
+    According to the specification, the information block for external links
+    contains 1 byte of version/flag information and two 0 terminated strings
+    for the object linked to and the full path.
+    Although not very useful, the minimum string length for each (with
+    terminating 0) would be one byte.
+    Checking this helps to avoid SEGVs triggered by bogus files.
+
+    (EFE - 2022/10/09 GH-2233)
\ No newline at end of file
diff --git a/src/H5Olink.c b/src/H5Olink.c
index 1c9579b..c3f8d63 100644
--- a/src/H5Olink.c
+++ b/src/H5Olink.c
@@ -240,6 +240,8 @@ H5O__link_decode(H5F_t *f, H5O_t H5_ATTR_UNUSED *open_oh, unsigned H5_ATTR_UNUSE
 
             /* A UD link.  Get the user-supplied data */
             UINT16DECODE(p, len)
+            if (lnk->type == H5L_TYPE_EXTERNAL && len < 3)
+                HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "external link information length < 3")
             lnk->u.ud.size = len;
             if (len > 0) {
                 /* Make sure that length doesn't exceed buffer size, which could
-- 
2.43.0

From 15233a43b381ece6131e0fa0288f730e97c0df99 Mon Sep 17 00:00:00 2001
From: Jordan Henderson <jhenderson@hdfgroup.org>
Date: Mon, 13 Dec 2021 01:23:16 -0600
Subject: [PATCH] Fix free list tracking and cleanup cast alignment warnings

---
 src/H5FL.c | 53 ++++++++++++++++++++++++++++++++++++-----------------
 1 file changed, 36 insertions(+), 17 deletions(-)

diff --git a/src/H5FL.c b/src/H5FL.c
index 95188d5bb3..6bd946f6cf 100644
--- a/src/H5FL.c
+++ b/src/H5FL.c
@@ -1000,24 +1000,32 @@ H5FL_blk_free(H5FL_blk_head_t *head, void *block)
 
 #ifdef H5FL_TRACK
     {
-        H5FL_track_t *trk = block = ((unsigned char *)block) - sizeof(H5FL_track_t);
+        unsigned char *block_ptr = ((unsigned char *)block) - sizeof(H5FL_track_t);
+        H5FL_track_t   trk;
+
+        HDmemcpy(&trk, block_ptr, sizeof(H5FL_track_t));
 
         /* Free tracking information about the allocation location */
-        H5CS_close_stack(trk->stack);
-        trk->file = H5MM_xfree(trk->file);
-        trk->func = H5MM_xfree(trk->func);
+        H5CS_close_stack(trk.stack);
+        /* The 'func' & 'file' strings are statically allocated (by the compiler)
+         * and are not allocated, so there's no need to free them.
+         */
+        trk.file = NULL;
+        trk.func = NULL;
 
         /* Remove from "outstanding allocations" list */
-        if (trk == H5FL_out_head_g) {
+        if ((void *)block_ptr == (void *)H5FL_out_head_g) {
             H5FL_out_head_g = H5FL_out_head_g->next;
             if (H5FL_out_head_g)
                 H5FL_out_head_g->prev = NULL;
         } /* end if */
         else {
-            trk->prev->next = trk->next;
-            if (trk->next)
-                trk->next->prev = trk->prev;
+            trk.prev->next = trk.next;
+            if (trk.next)
+                trk.next->prev = trk.prev;
         } /* end else */
+
+        HDmemcpy(block_ptr, &trk, sizeof(H5FL_track_t));
     }
 #endif /* H5FL_TRACK */
 
@@ -1116,19 +1124,30 @@ H5FL_blk_realloc(H5FL_blk_head_t *head, void *block, size_t new_size H5FL_TRACK_
         else {
 #ifdef H5FL_TRACK
             {
-                H5FL_track_t *trk = (H5FL_track_t *)(((unsigned char *)block) - sizeof(H5FL_track_t));
+                unsigned char *block_ptr = ((unsigned char *)block) - sizeof(H5FL_track_t);
+                H5FL_track_t   trk;
+
+                HDmemcpy(&trk, block_ptr, sizeof(H5FL_track_t));
 
                 /* Release previous tracking information */
-                H5CS_close_stack(trk->stack);
-                trk->file = H5MM_xfree(trk->file);
-                trk->func = H5MM_xfree(trk->func);
+                H5CS_close_stack(trk.stack);
+                /* The 'func' & 'file' strings are statically allocated (by the compiler)
+                 * and are not allocated, so there's no need to free them.
+                 */
+                trk.file = NULL;
+                trk.func = NULL;
 
                 /* Store new tracking information */
-                trk->stack = H5CS_copy_stack();
-                HDassert(trk->stack);
-                trk->file = H5MM_strdup(call_file);
-                trk->func = H5MM_strdup(call_func);
-                trk->line = call_line;
+                trk.stack = H5CS_copy_stack();
+                HDassert(trk.stack);
+                /* The 'call_func' & 'call_file' strings are statically allocated (by the compiler)
+                 * there's no need to duplicate them.
+                 */
+                trk.file = call_file;
+                trk.func = call_func;
+                trk.line = call_line;
+
+                HDmemcpy(block_ptr, &trk, sizeof(H5FL_track_t));
             }
 #endif /* H5FL_TRACK */
             ret_value = block;
-- 
2.43.0

From 8db206edbd3fe96f6726b458b834c9495e1da372 Mon Sep 17 00:00:00 2001
From: Egbert Eich <eich@suse.com>
Date: Fri, 2 Dec 2022 21:24:14 +0100
Subject: [PATCH] CVE 2021 46242 develop (#2255)

* When evicting driver info block, NULL the corresponding entry

Since H5C_expunge_entry() called (from H5AC_expunge_entry()) sets the  flag
H5C__FLUSH_INVALIDATE_FLAG, the driver info block will be freed. NULLing the
pointer in  f->shared->drvinfo will prevent use-after-free  when it is used in other
functions (like  H5F__dest()) - as other places will check whether the pointer is
initialized before using its value.

This fixes CVE-2021-46242 / Bug #2254

Signed-off-by: Egbert Eich <eich@suse.com>

* When evicting the superblock, NULL the corresponding entry

The call to H5AC_expunge_entry() will free the corresonding structure,
to avoid a use-after-free, the corrsponding pointer entry will be NULLed.

Signed-off-by: Egbert Eich <eich@suse.com>

Signed-off-by: Egbert Eich <eich@suse.com>
---
 release_docs/RELEASE.txt | 12 ++++++++++++
 src/H5Fsuper.c           |  8 ++++++--
 2 files changed, 18 insertions(+), 2 deletions(-)

diff --git a/release_docs/RELEASE.txt b/release_docs/RELEASE.txt
index 1f69197827..c76d33e4f8 100644
--- a/release_docs/RELEASE.txt
+++ b/release_docs/RELEASE.txt
@@ -468,6 +468,18 @@ Bug Fixes since HDF5-1.10.7 release
 ===================================
     Library
     -------
+    - Fix CVE-2021-46242 / GHSA-x9pw-hh7v-wjpf
+
+      When evicting driver info block, NULL the corresponding entry.
+
+      Since H5C_expunge_entry() called (from H5AC_expunge_entry()) sets the  flag
+      H5C__FLUSH_INVALIDATE_FLAG, the driver info block will be freed. NULLing
+      the pointer in f->shared->drvinfo will prevent use-after-free  when it is
+      used in other functions (like  H5F__dest()) - as other places will check
+      whether the pointer is initialized before using its value.
+
+      (EFE - 2022/09/29 GH-2254)
+
     - Fixed CVE-2018-17432
 
         The tool h5repack produced a segfault on a corrupted file which had
diff --git a/src/H5Fsuper.c b/src/H5Fsuper.c
index bc4319a1ac..85dafec6a4 100644
--- a/src/H5Fsuper.c
+++ b/src/H5Fsuper.c
@@ -1043,8 +1043,11 @@ done:
                 HDONE_ERROR(H5E_FILE, H5E_CANTUNPIN, FAIL, "unable to unpin driver info")
 
             /* Evict the driver info block from the cache */
-            if (H5AC_expunge_entry(f, H5AC_DRVRINFO, sblock->driver_addr, H5AC__NO_FLAGS_SET) < 0)
-                HDONE_ERROR(H5E_FILE, H5E_CANTEXPUNGE, FAIL, "unable to expunge driver info block")
+            if (sblock) {
+                if (H5AC_expunge_entry(f, H5AC_DRVRINFO, sblock->driver_addr, H5AC__NO_FLAGS_SET) < 0)
+                    HDONE_ERROR(H5E_FILE, H5E_CANTEXPUNGE, FAIL, "unable to expunge driver info block")
+                f->shared->drvinfo = NULL;
+            }
         } /* end if */
 
         /* Unpin & discard superblock */
@@ -1056,6 +1059,7 @@ done:
             /* Evict the superblock from the cache */
             if (H5AC_expunge_entry(f, H5AC_SUPERBLOCK, (haddr_t)0, H5AC__NO_FLAGS_SET) < 0)
                 HDONE_ERROR(H5E_FILE, H5E_CANTEXPUNGE, FAIL, "unable to expunge superblock")
+            f->shared->sblock = NULL;
         } /* end if */
     }     /* end if */
 
-- 
2.43.0

From bbc7db1c86fccf7e52b0fc6fa30dbfd7c557cf6f Mon Sep 17 00:00:00 2001
Date: Tue, 12 Aug 2025 18:13:28 +0530
Subject: [PATCH] asdf

---
 ROOT-SECURITY-RELEASE.md | 58 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 58 insertions(+)
 create mode 100644 ROOT-SECURITY-RELEASE.md

diff --git a/ROOT-SECURITY-RELEASE.md b/ROOT-SECURITY-RELEASE.md
new file mode 100644
index 0000000000..a97eef2c3e
--- /dev/null
+++ b/ROOT-SECURITY-RELEASE.md
@@ -0,0 +1,58 @@
+## Why You Cannot Fix **HDF5** via Code Patching in Containers
+
+## Overview: What Is **HDF5**?
+
+**HDF5** (Hierarchical Data Format 5) is a **data management and storage library** designed to store and organize large amounts of numerical data. It provides a flexible data model that can represent very complex data objects and a wide variety of metadata.
+
+The **HDF5** package consists of:
+- **Core Library**: Main data storage and retrieval functions
+- **Command-Line Utilities**: Tools like `h5dump`, `h5repack`, `h5copy`, etc.
+- **Memory Management**: Efficient allocation and cleanup utilities
+- **Data Processing**: Support for various data types and structures
+- **File Format**: Self-describing file format for scientific data
+
+**HDF5** is used in scientific computing, data analysis, machine learning, and various applications that require efficient storage and retrieval of large datasets.
+
+---
+## üìå CVE-2018-14033 ‚Äì False Positive for HDF5 1.10.8
+
+**Component:** Layout message decoding functionality in **HDF5**  
+**Issue:** A heap-based buffer over-read vulnerability was identified in the `H5O_layout_decode` function in HDF5 1.8.20 when processing corrupted HDF5 files with invalid storage size values during layout message decoding.  
+**Impact:** Potential segmentation fault when processing maliciously corrupted HDF5 files with invalid layout information.
+
+---
+
+## üîç Vulnerability Overview
+
+- **Component impacted:** Layout message decoding functionality in **HDF5** (version 1.8.20)
+- **Nature of issue:** Buffer over-read during layout message processing with corrupted storage size values
+- **Attack vector:** Maliciously corrupted HDF5 files with invalid layout message data
+
+---
+
+## ‚úÖ HDF5 1.10.8 ‚Äì Why This is a False Positive
+
+- **Debian HDF5 1.10.8 already contains the fix** - The vulnerability was patched in commit `dafc7285bb` on March 19, 2021, and this fix is already present in the HDF5 1.10.8 package distributed by Debian
+- The vulnerability only affects **specific file corruption scenarios** with corrupted layout message data
+- **Limited scope:** This vulnerability is specifically in the layout message decoding code, not in the core data storage library
+- **Already patched:** Since Debian's HDF5 1.10.8 includes the security fix, the vulnerable code path has been eliminated
+- **Not exploitable in properly formatted files:** The vulnerability requires specifically corrupted HDF5 files with malicious layout message data, which is unlikely in typical usage
+- **Buffer overflow protection added:** The actual fix adds proper buffer boundary checks to prevent the over-read condition
+
+---
+
+## ‚ö†Ô∏è Why You Don't Need to Fix It
+
+- **Debian's HDF5 1.10.8 is already patched** - The vulnerable layout message decoding code has been fixed with proper buffer overflow protection
+- The issue only occurs when **processing specifically corrupted HDF5 files** with invalid layout message data
+- **Statement from security analysis:** "Fixed in 1.10.x-series in 1.10.8" is significant because:
+  - **Different codebase:** HDF5 1.10.8 was released after the CVE fix was committed (October 29, 2021 vs March 19, 2021)
+  - **Security patches included:** The vulnerability has been addressed with proper buffer boundary validation
+
+
+---
+
+## üîó References
+
+- [**GitHub Commit Fix**](https://github.com/HDFGroup/hdf5/commit/dafc7285bb1df4a6529a64c215c5de4017016d24): The actual code fix for CVE-2018-14033
+- [**CVE Record**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-14033): National Vulnerability Database entry for CVE-2018-14033
\ No newline at end of file
-- 
2.43.0

From b325aaba5e122cf9b08692e6405587d50fd89658 Mon Sep 17 00:00:00 2001
Date: Tue, 12 Aug 2025 12:09:01 +0530
Subject: [PATCH] H5O_dtype_decode_helper: Parent of enum needs to have same
 size as enum itself (#2237) The size of the enumeration values is determined
 by the size of the parent. Functions accessing the enumeration values use the
 size of the enumeration to determine the size of each element and how much
 data to copy. Thus the size of the enumeration and its parent need to match.
 Check here to avoid unpleasant surprises later.

This fixes CVE-2018-14031 / Bug #2236.

Signed-off-by: Egbert Eich <eich@suse.com>
---
 release_docs/RELEASE.txt | 20 ++++++++++++++++++++
 src/H5Odtype.c           |  2 ++
 2 files changed, 22 insertions(+)

diff --git a/release_docs/RELEASE.txt b/release_docs/RELEASE.txt
index 1f69197827..f0491d8ee9 100644
--- a/release_docs/RELEASE.txt
+++ b/release_docs/RELEASE.txt
@@ -498,6 +498,26 @@ Bug Fixes since HDF5-1.10.7 release
 
         (JWSB - 2021/09/13)
 
+    - Fix CVE-2018-14031 / GHSA-2xc7-724c-r36j
+
+      Parent of enum datatype message must have the same size as the
+      enum datatype message itself.
+      Functions accessing the enumeration values use the size of the
+      enumeration datatype to determine the size of each element and
+      how much data to copy.
+      Thus the size of the enumeration and its parent need to match.
+      Check in H5O_dtype_decode_helper()  to avoid unpleasant surprises
+      later.
+
+      (EFE - 2022/09/28 GH-2236)
+
+    - Fix CVE-2018-17439 / GHSA-vcxv-vp43-rch7
+
+      Fixed a vulnerability in the HDF5 library that could lead to
+      security issues when processing certain malformed files.
+
+      (EFE - 2022/09/28 GH-2237)
+
     - Fixed CVE-2020-10810 - an invalid read and memory leak when parsing
       corrupt file space info messages
 
diff --git a/src/H5Odtype.c b/src/H5Odtype.c
index ac0341076e..196c6f68bc 100644
--- a/src/H5Odtype.c
+++ b/src/H5Odtype.c
@@ -458,6 +458,8 @@ H5O_dtype_decode_helper(H5F_t *f, unsigned *ioflags /*in,out*/, const uint8_t **
                 HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL, "memory allocation failed")
             if (H5O_dtype_decode_helper(f, ioflags, pp, dt->shared->parent) < 0)
                 HGOTO_ERROR(H5E_DATATYPE, H5E_CANTDECODE, FAIL, "unable to decode parent datatype")
+            if (dt->shared->parent->shared->size != dt->shared->size)
+                HGOTO_ERROR(H5E_DATATYPE, H5E_BADSIZE, FAIL, "ENUM datatype size does not match parent")
 
             /* Check if the parent of this enum has a version greater than the
              * enum itself. */
-- 
2.43.0

From 7d2fdc682551f9b34adf8e0e61ca53d4a8957263 Mon Sep 17 00:00:00 2001
From: Egbert Eich <eich@suse.de>
Date: Wed, 9 Nov 2022 19:25:11 +0100
Subject: [PATCH] H5O__pline_decode() Make more resilient to out-of-bounds read
 (#2210)

Malformed hdf5 files may have trunkated content which does not match
the expected size. When this function attempts to decode these it may
read past the end of the allocated space leading to heap overflows
as bounds checking is incomplete.
Make sure each element is within bounds before reading.

This fixes CVE-2019-8396 / HDFFV-10712 / github bug #2209.

Signed-off-by: Egbert Eich <eich@suse.com>

Signed-off-by: Egbert Eich <eich@suse.com>
---
 src/H5Opline.c  | 17 +++++++++++++++--
 src/H5private.h |  3 +++
 2 files changed, 18 insertions(+), 2 deletions(-)

diff --git a/src/H5Opline.c b/src/H5Opline.c
index c679462dd5..4655ed1674 100644
--- a/src/H5Opline.c
+++ b/src/H5Opline.c
@@ -109,6 +109,7 @@ H5FL_DEFINE(H5O_pline_t);
  *
  *-------------------------------------------------------------------------
  */
+
 static void *
 H5O__pline_decode(H5F_t H5_ATTR_UNUSED *f, H5O_t H5_ATTR_UNUSED *open_oh, unsigned H5_ATTR_UNUSED mesg_flags,
                   unsigned H5_ATTR_UNUSED *ioflags, size_t p_size, const uint8_t *p)
@@ -130,6 +131,9 @@ H5O__pline_decode(H5F_t H5_ATTR_UNUSED *f, H5O_t H5_ATTR_UNUSED *open_oh, unsign
         HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, "memory allocation failed")
 
     /* Version */
+    if (p + 4 - 1 > p_end) /* 4 byte is minimum for all versions */
+        HGOTO_ERROR(H5E_OHDR, H5E_NOSPACE, NULL, "ran off the end of the buffer: current p = %p, p_end = %p",
+                    p + 4, p_end)
     pline->version = *p++;
     if (pline->version < H5O_PLINE_VERSION_1 || pline->version > H5O_PLINE_VERSION_LATEST)
         HGOTO_ERROR(H5E_PLINE, H5E_CANTLOAD, NULL, "bad version number for filter pipeline message")
@@ -158,6 +162,9 @@ H5O__pline_decode(H5F_t H5_ATTR_UNUSED *f, H5O_t H5_ATTR_UNUSED *open_oh, unsign
     /* Decode filters */
     for (i = 0, filter = &pline->filter[0]; i < pline->nused; i++, filter++) {
         /* Filter ID */
+        if (p + 6 - 1 > p_end) /* 6 bytes minimum */
+            HGOTO_ERROR(H5E_OHDR, H5E_NOSPACE, NULL,
+                        "ran off the end of the buffer: current p = %p, p_end = %p", p + 6, p_end)
         UINT16DECODE(p, filter->id);
 
         /* Length of filter name */
@@ -167,6 +174,9 @@ H5O__pline_decode(H5F_t H5_ATTR_UNUSED *f, H5O_t H5_ATTR_UNUSED *open_oh, unsign
             UINT16DECODE(p, name_length);
             if (pline->version == H5O_PLINE_VERSION_1 && name_length % 8)
                 HGOTO_ERROR(H5E_PLINE, H5E_CANTLOAD, NULL, "filter name length is not a multiple of eight")
+            if (p + 4 - 1 > p_end) /* with name_length 4 bytes to go */
+                HGOTO_ERROR(H5E_OHDR, H5E_NOSPACE, NULL,
+                            "ran off the end of the buffer: current p = %p, p_end = %p", p + 4, p_end)
         } /* end if */
 
         /* Filter flags */
@@ -178,9 +188,12 @@ H5O__pline_decode(H5F_t H5_ATTR_UNUSED *f, H5O_t H5_ATTR_UNUSED *open_oh, unsign
         /* Filter name, if there is one */
         if (name_length) {
             size_t actual_name_length; /* Actual length of name */
-
+            size_t len = (size_t)(p_end - p + 1);
             /* Determine actual name length (without padding, but with null terminator) */
-            actual_name_length = HDstrlen((const char *)p) + 1;
+            actual_name_length = HDstrnlen((const char *)p, len);
+            if (actual_name_length == len)
+                HGOTO_ERROR(H5E_OHDR, H5E_NOSPACE, NULL, "filter name not null terminated")
+            actual_name_length += 1; /* include \0 byte */
             HDassert(actual_name_length <= name_length);
 
             /* Allocate space for the filter name, or use the internal buffer */
diff --git a/src/H5private.h b/src/H5private.h
index 931d7b9046..4656b4d601 100644
--- a/src/H5private.h
+++ b/src/H5private.h
@@ -1402,6 +1402,9 @@ H5_DLL void HDsrand(unsigned int seed);
 #endif /* HDstrftime */
 #ifndef HDstrlen
 #define HDstrlen(S) strlen(S)
+#endif
+#ifndef HDstrnlen
+#define HDstrnlen(S, L) strnlen(S, L)
 #endif /* HDstrlen */
 #ifndef HDstrncat
 #define HDstrncat(X, Y, Z) strncat(X, Y, Z)
-- 
2.43.0
From b16ec83d4bd79f9ffaad85de16056419f3532887 Mon Sep 17 00:00:00 2001
From: Egbert Eich <eich@suse.com>
Date: Thu, 2 Mar 2023 18:17:49 +0100
Subject: [PATCH] Fix CVE-2021-37501: Check for overflow when calculating on-disk attribute data size

Fix CVE-2021-37501 / GHSA-rfgw-5vq3-wrjf

Check for overflow when calculating on-disk attribute data size.

A bogus hdf5 file may contain dataspace messages with sizes
which lead to the on-disk data sizes to exceed what is addressable.
When calculating the size, make sure, the multiplication does not
overflow.
The test case was crafted in a way that the overflow caused the
size to be 0.

---
 src/H5Oattr.c | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/src/H5Oattr.c b/src/H5Oattr.c
index 638686587d..e431cd2e62 100644
--- a/src/H5Oattr.c
+++ b/src/H5Oattr.c
@@ -221,10 +221,6 @@ H5O__attr_decode(H5F_t *f, H5O_t *open_oh, unsigned H5_ATTR_UNUSED mesg_flags, u
     else
         p += attr->shared->ds_size;
 
-    /* Get the datatype's size */
-    if (0 == (dt_size = H5T_get_size(attr->shared->dt)))
-        HGOTO_ERROR(H5E_ATTR, H5E_CANTGET, NULL, "unable to get datatype size")
-
     /* Get the datatype & dataspace sizes */
     if (0 == (dt_size = H5T_get_size(attr->shared->dt)))
         HGOTO_ERROR(H5E_ATTR, H5E_CANTGET, NULL, "unable to get datatype size")
@@ -234,6 +230,9 @@ H5O__attr_decode(H5F_t *f, H5O_t *open_oh, unsigned H5_ATTR_UNUSED mesg_flags, u
 
     /* Compute the size of the data */
     H5_CHECKED_ASSIGN(attr->shared->data_size, size_t, ds_size * (hsize_t)dt_size, hsize_t);
+    /* Check if multiplication has overflown */
+    if ((attr->shared->data_size / dt_size) != ds_size)
+        HGOTO_ERROR(H5E_RESOURCE, H5E_OVERFLOW, NULL, "data size exceeds addressable range")
 
     /* Go get the data */
     if (attr->shared->data_size) {

