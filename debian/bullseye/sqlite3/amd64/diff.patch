From 07307a5aa6075769a0bc72b5a5b80ab89e0df082 Mon Sep 17 00:00:00 2001
Date: Tue, 19 Aug 2025 10:00:01 +0530
Subject: [PATCH] Fix: CVE-2025-6965

---
 src/expr.c      | 14 ++++++++++++--
 src/sqliteInt.h |  6 +++---
 2 files changed, 15 insertions(+), 5 deletions(-)

diff --git a/src/expr.c b/src/expr.c
index 685f041752..632d51813e 100644
--- a/src/expr.c
+++ b/src/expr.c
@@ -5872,6 +5872,11 @@ static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
             if( (k>=pAggInfo->nColumn)
              && (k = addAggInfoColumn(pParse->db, pAggInfo))>=0 
             ){
+              int mxTerm = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];
+              if( k>=mxTerm ){
+                sqlite3ErrorMsg(pParse, "more than %d aggregate terms", mxTerm);
+                return WRC_Abort;
+              }
               pCol = &pAggInfo->aCol[k];
               pCol->pTab = pExpr->y.pTab;
               pCol->iTable = pExpr->iTable;
@@ -5905,7 +5910,7 @@ static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
             ExprSetVVAProperty(pExpr, EP_NoReduce);
             pExpr->pAggInfo = pAggInfo;
             pExpr->op = TK_AGG_COLUMN;
-            pExpr->iAgg = (i16)k;
+            pExpr->iAgg = k;
             break;
           } /* endif pExpr->iTable==pItem->iCursor */
         } /* end loop over pSrcList */
@@ -5931,6 +5936,11 @@ static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
           u8 enc = ENC(pParse->db);
           i = addAggInfoFunc(pParse->db, pAggInfo);
           if( i>=0 ){
+            int mxTerm = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];
+            if( i>=mxTerm ){
+              sqlite3ErrorMsg(pParse, "more than %d aggregate terms", mxTerm);
+              return WRC_Abort;
+            }
             assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
             pItem = &pAggInfo->aFunc[i];
             pItem->pFExpr = pExpr;
@@ -5950,7 +5960,7 @@ static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
         */
         assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );
         ExprSetVVAProperty(pExpr, EP_NoReduce);
-        pExpr->iAgg = (i16)i;
+        pExpr->iAgg = i;
         pExpr->pAggInfo = pAggInfo;
         return WRC_Prune;
       }else{
diff --git a/src/sqliteInt.h b/src/sqliteInt.h
index 4670622779..6a75a5b1ac 100644
--- a/src/sqliteInt.h
+++ b/src/sqliteInt.h
@@ -2535,8 +2535,8 @@ struct AggInfo {
     Expr *pCExpr;            /* The original expression */
     int iTable;              /* Cursor number of the source table */
     int iMem;                /* Memory location that acts as accumulator */
-    i16 iColumn;             /* Column number within the source table */
-    i16 iSorterColumn;       /* Column number in the sorting index */
+    int iColumn;             /* Column number within the source table */
+    int iSorterColumn;       /* Column number in the sorting index */
   } *aCol;
   int nColumn;            /* Number of used entries in aCol[] */
   int nAccumulator;       /* Number of columns that show through to the output.
@@ -2678,7 +2678,7 @@ struct Expr {
   ynVar iColumn;         /* TK_COLUMN: column index.  -1 for rowid.
                          ** TK_VARIABLE: variable number (always >= 1).
                          ** TK_SELECT_COLUMN: column of the result vector */
-  i16 iAgg;              /* Which entry in pAggInfo->aCol[] or ->aFunc[] */
+  int iAgg;              /* Which entry in pAggInfo->aCol[] or ->aFunc[] */
   i16 iRightJoinTable;   /* If EP_FromJoin, the right table of the join */
   AggInfo *pAggInfo;     /* Used by TK_AGG_COLUMN and TK_AGG_FUNCTION */
   union {
-- 
2.50.1

