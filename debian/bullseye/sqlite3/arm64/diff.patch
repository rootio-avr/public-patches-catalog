From a60a644841473cafd7eedd140b4a172f8e6729c0 Mon Sep 17 00:00:00 2001
Date: Tue, 19 Aug 2025 12:48:56 +0530
Subject: [PATCH] backported CVE-2025-29088

---
 src/main.c | 42 ++++++++++++++++++++++++++----------------
 1 file changed, 26 insertions(+), 16 deletions(-)

Index: sqlite3-3.34.1/src/main.c
===================================================================
--- sqlite3-3.34.1.orig/src/main.c
+++ sqlite3-3.34.1/src/main.c
@@ -742,17 +742,22 @@ int sqlite3_config(int op, ...){
 ** If lookaside is already active, return SQLITE_BUSY.
 **
 ** The sz parameter is the number of bytes in each lookaside slot.
-** The cnt parameter is the number of slots.  If pStart is NULL the
-** space for the lookaside memory is obtained from sqlite3_malloc().
-** If pStart is not NULL then it is sz*cnt bytes of memory to use for
-** the lookaside memory.
+** The cnt parameter is the number of slots.  If pBuf is NULL the
+** space for the lookaside memory is obtained from sqlite3_malloc()
+** or similar.  If pBuf is not NULL then it is sz*cnt bytes of memory
+** to use for the lookaside memory.
 */
-static int setupLookaside(sqlite3 *db, void *pBuf, int sz, int cnt){
+static int setupLookaside(
+  sqlite3 *db,    /* Database connection being configured */
+  void *pBuf,     /* Memory to use for lookaside.  May be NULL */
+  int sz,         /* Desired size of each lookaside memory slot */
+  int cnt         /* Number of slots to allocate */
+){
 #ifndef SQLITE_OMIT_LOOKASIDE
-  void *pStart;
-  sqlite3_int64 szAlloc = sz*(sqlite3_int64)cnt;
-  int nBig;   /* Number of full-size slots */
-  int nSm;    /* Number smaller LOOKASIDE_SMALL-byte slots */
+  void *pStart;          /* Start of the lookaside buffer */
+  sqlite3_int64 szAlloc; /* Total space set aside for lookaside memory */
+  int nBig;              /* Number of full-size slots */
+  int nSm;               /* Number smaller LOOKASIDE_SMALL-byte slots */
   
   if( sqlite3LookasideUsed(db,0)>0 ){
     return SQLITE_BUSY;
@@ -765,17 +770,22 @@ static int setupLookaside(sqlite3 *db, v
     sqlite3_free(db->lookaside.pStart);
   }
   /* The size of a lookaside slot after ROUNDDOWN8 needs to be larger
-  ** than a pointer to be useful.
+  ** than a pointer and small enough to fit in a u16.
   */
-  sz = ROUNDDOWN8(sz);  /* IMP: R-33038-09382 */
+  sz = ROUNDDOWN8(sz);
   if( sz<=(int)sizeof(LookasideSlot*) ) sz = 0;
-  if( cnt<0 ) cnt = 0;
-  if( sz==0 || cnt==0 ){
+  if( sz>65528 ) sz = 65528;
+  /* Count must be at least 1 to be useful, but not so large as to use
+  ** more than 0x7fff0000 total bytes for lookaside. */
+  if( cnt<1 ) cnt = 0;
+  if( sz>0 && cnt>(0x7fff0000/sz) ) cnt = 0x7fff0000/sz;
+  szAlloc = (i64)sz*(i64)cnt;
+  if( szAlloc==0 ){
     sz = 0;
     pStart = 0;
   }else if( pBuf==0 ){
     sqlite3BeginBenignMalloc();
-    pStart = sqlite3Malloc( szAlloc );  /* IMP: R-61949-35727 */
+    pStart = sqlite3Malloc( szAlloc );
     sqlite3EndBenignMalloc();
     if( pStart ) szAlloc = sqlite3MallocSize(pStart);
   }else{
@@ -784,10 +794,10 @@ static int setupLookaside(sqlite3 *db, v
 #ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
   if( sz>=LOOKASIDE_SMALL*3 ){
     nBig = szAlloc/(3*LOOKASIDE_SMALL+sz);
-    nSm = (szAlloc - sz*nBig)/LOOKASIDE_SMALL;
+    nSm = (szAlloc - (i64)sz*(i64)nBig)/LOOKASIDE_SMALL;
   }else if( sz>=LOOKASIDE_SMALL*2 ){
     nBig = szAlloc/(LOOKASIDE_SMALL+sz);
-    nSm = (szAlloc - sz*nBig)/LOOKASIDE_SMALL;
+    nSm = (szAlloc - (i64)sz*(i64)nBig)/LOOKASIDE_SMALL;
   }else
 #endif /* SQLITE_OMIT_TWOSIZE_LOOKASIDE */
   if( sz>0 ){
From 07307a5aa6075769a0bc72b5a5b80ab89e0df082 Mon Sep 17 00:00:00 2001
Date: Tue, 19 Aug 2025 10:00:01 +0530
Subject: [PATCH] Fix: CVE-2025-6965

---
 src/expr.c      | 14 ++++++++++++--
 src/sqliteInt.h |  6 +++---
 2 files changed, 15 insertions(+), 5 deletions(-)

diff --git a/src/expr.c b/src/expr.c
index 685f041752..632d51813e 100644
--- a/src/expr.c
+++ b/src/expr.c
@@ -5872,6 +5872,11 @@ static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
             if( (k>=pAggInfo->nColumn)
              && (k = addAggInfoColumn(pParse->db, pAggInfo))>=0 
             ){
+              int mxTerm = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];
+              if( k>=mxTerm ){
+                sqlite3ErrorMsg(pParse, "more than %d aggregate terms", mxTerm);
+                return WRC_Abort;
+              }
               pCol = &pAggInfo->aCol[k];
               pCol->pTab = pExpr->y.pTab;
               pCol->iTable = pExpr->iTable;
@@ -5905,7 +5910,7 @@ static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
             ExprSetVVAProperty(pExpr, EP_NoReduce);
             pExpr->pAggInfo = pAggInfo;
             pExpr->op = TK_AGG_COLUMN;
-            pExpr->iAgg = (i16)k;
+            pExpr->iAgg = k;
             break;
           } /* endif pExpr->iTable==pItem->iCursor */
         } /* end loop over pSrcList */
@@ -5931,6 +5936,11 @@ static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
           u8 enc = ENC(pParse->db);
           i = addAggInfoFunc(pParse->db, pAggInfo);
           if( i>=0 ){
+            int mxTerm = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];
+            if( i>=mxTerm ){
+              sqlite3ErrorMsg(pParse, "more than %d aggregate terms", mxTerm);
+              return WRC_Abort;
+            }
             assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
             pItem = &pAggInfo->aFunc[i];
             pItem->pFExpr = pExpr;
@@ -5950,7 +5960,7 @@ static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
         */
         assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );
         ExprSetVVAProperty(pExpr, EP_NoReduce);
-        pExpr->iAgg = (i16)i;
+        pExpr->iAgg = i;
         pExpr->pAggInfo = pAggInfo;
         return WRC_Prune;
       }else{
diff --git a/src/sqliteInt.h b/src/sqliteInt.h
index 4670622779..6a75a5b1ac 100644
--- a/src/sqliteInt.h
+++ b/src/sqliteInt.h
@@ -2535,8 +2535,8 @@ struct AggInfo {
     Expr *pCExpr;            /* The original expression */
     int iTable;              /* Cursor number of the source table */
     int iMem;                /* Memory location that acts as accumulator */
-    i16 iColumn;             /* Column number within the source table */
-    i16 iSorterColumn;       /* Column number in the sorting index */
+    int iColumn;             /* Column number within the source table */
+    int iSorterColumn;       /* Column number in the sorting index */
   } *aCol;
   int nColumn;            /* Number of used entries in aCol[] */
   int nAccumulator;       /* Number of columns that show through to the output.
@@ -2678,7 +2678,7 @@ struct Expr {
   ynVar iColumn;         /* TK_COLUMN: column index.  -1 for rowid.
                          ** TK_VARIABLE: variable number (always >= 1).
                          ** TK_SELECT_COLUMN: column of the result vector */
-  i16 iAgg;              /* Which entry in pAggInfo->aCol[] or ->aFunc[] */
+  int iAgg;              /* Which entry in pAggInfo->aCol[] or ->aFunc[] */
   i16 iRightJoinTable;   /* If EP_FromJoin, the right table of the join */
   AggInfo *pAggInfo;     /* Used by TK_AGG_COLUMN and TK_AGG_FUNCTION */
   union {
-- 
2.50.1

